\documentclass[10pt]{scrartcl}
\usepackage[latin1]{inputenc}
\usepackage{bibgerm}
\usepackage[english, ngerman]{babel}
\usepackage[babel]{csquotes}
\usepackage{cite}
\usepackage{amsmath} % for eqref
\usepackage{tabularx}
\author{Denis Dietze\footnote{denis.dietze@st.ovgu.de} \and Wolfgang Keller\footnote{wolfgang.keller@student.uni-magdeburg.de} \and Nico Linke\footnote{nicolinke@googlemail.com} \and Thomas Schulte\footnote{thomas.schulte.md@googlemail.com}}
\title{Protokoll Versuch E10/IT7}
\subtitle{Mikroprozessor -- Grundlagenversuch Z 80 (Z 84 C 0008)}

\begin{document}
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{3}
\maketitle
\tableofcontents
\section{Studienkontrollfragen}

\subsection{Maschinenzyklus}

\subsubsection{Frage}

Was ist ein Maschinenzyklus?

\subsubsection{Antwort}

Laut \cite[S.~27]{KieserMeder86} ist ein \emph{Maschinenzyklus} durch die Gesamtzahl der Takte einer Grundfunktion definiert. Eine oder mehrere Maschinenzyklen bilden dann einen \emph{Instruktionszyklus}. Grundfunktionen bilden:
\begin{itemize}
\item Befehlscode lesen
\item Speicher lesen
\item Speicher schreiben
\item I/O lesen
\item I/O schreiben
\item Interruptbestätigung
\item CPU-interne Operation.
\end{itemize}

\subsection{Registerstruktur}

\subsubsection{Frage}

Beschreiben Sie die Registerstruktur der Z 80 CPU und erläutern Sie die Besonderheiten und Verwendungsmöglichkeiten der Register!

\subsubsection{Antwort}

Der Registersatz der Z 80 CPU besteht (vgl. \cite[S.~22ff]{KieserMeder86}) aus "`allgemeinen Registern"' und "`Spezialregistern"'. 

\paragraph{Allgemeine Register} ~\\

\begin{tabular}{|c|c|c|c|}
\multicolumn{2}{c}{Hauptregistersatz} & \multicolumn{2}{c}{Tauschregistersatz} \\
\hline
    Akkumulator A & Flags F & Akkumulator A' & Flags F' \\
    \hline
    B & C & B' & C' \\
    \hline
    D & E & D' & E' \\
    \hline
    H & L & H' & L' \\
\hline
\end{tabular}
\\

Die allgemeinen Register teilen sich weiter in zwei Registers"atze auf: einen Hauptregistersatz und einen Tauschregistersatz. Jeder dieser beiden Registers"atze enth"alt acht 8-Bit-Register, die wir mit A, F, B, C, D, E, H und L bzw. A', F', B', C', D', E', H' und L' bezeichnen.

Das Register A bzw. A' bezeichnen wir als "`Akkumulator"' und das Register F bzw. F' als "`Flagsregister"'. Diese beiden sind f"ur spezielle Aufgaben vorgesehen. Die anderen 6 allgemeinen Register werden f"ur die allgemeine Verwendung benutzt.

Die Registerpaare B-C, D-E und H-L lassen sich auch als 16-Bit-Registerpaar nutzen.

Mit einem Befehl lassen sich A und F durch den Inhalt der Tauschregister tauschen. Mit einem weiteren lassen sich die sechs Allzweckregister durch ihre Tauschregister ersetzen. Dies kann beispielsweise f"ur eine schnelle Interrupt-Verarbeitung eingesetzt werden, da das Austauschen dieser Register deutlich schneller ist, als den Inhalt der Register auf einen externen Stack zu retten, wie es beispielsweise auf X86-basierenden Architekturen h"aufig in Interrupt-Service-Routinen getan wird.

\paragraph{Spezialregister} ~\\

\begin{tabular}{|c|c|}
\hline
Interruptvektorregister I & Refreshregister R \\
\hline
\multicolumn{2}{|c|}{Indexregister IX} \\
\hline
\multicolumn{2}{|c|}{Indexregister IY} \\
\hline
\multicolumn{2}{|c|}{Stack Pointer SP} \\
\hline
\multicolumn{2}{|c|}{Program Counter PC} \\
\hline
\end{tabular}
\\

Die \emph{Spezialregister} bestehen aus den zwei 8-Bit-Registern I (Interruptvektor-Register) und R (Refresh-Register), sowie vier 16-Bit-Registern: den zwei Index-Registern IX und IY, dem Stack Pointer SP und dem Program Counter PC.

Der Program Counter PC enth"alt die 16-Bit-Adresse des aktuellen Instruktions-Bytes. Er wird automatisch inkrementiert, wenn sein Inhalt auf den Adressbus geladen wird.

Der Stack Pointer SP enthält die Adresse der aktuellen Spitze des Stacks.

Die Indexregister IX und IY dienen als Basis zur indizierten Adressierung und zur 16-Bit-Datenmanipulation. 

Das Interruptvektor-Register I stellt in der Interrupt-Betriebsart IM2 das High Byte der Adresse der Interrupt Service Routine (ISR) bereit. Das Low Byte wird von dem interruptanordernden peripheren Element geliefert.

Vom Refresh-Register R werden nur die unteren 7 Bits verwendet und dient f"ur den Programmierer transparent zum regelm"a"sigen Auffrischen des Speichers. Es wird beim Holen einer Instruktion inkrementiert -- somit l"asst es sich als Instruktionsz"ahler f"ur M1-Zyklen benutzen. Seine Daten werden im M1-Zyklus als unterer Teil der Adresse zusammen mit dem RFSH-Signal ausgesendet.

\subsection{Daten- vs. Befehlsbytes}

\subsubsection{Frage}

Wodurch werden Daten- und Befehlsbytes unterschieden?

\subsubsection{Antwort}

Wenn auf dem Steuerbus ein M1-Signal anliegt, so wird das aktuelle Byte als Befehlsbyte betrachtet, sonst als Datenbyte.

\subsection{Steuersignale}

\subsubsection{Frage}

Erläutern Sie die Aufgaben der Steuersignale der Z 80 CPU!

\subsubsection{Antwort}

Zur Beschreibung der Aufgaben der Steuersignale vgl. \cite[S.~25ff]{KieserMeder86}.

Wir unterscheiden drei Typen von Steuersignalen:

\begin{itemize}
\item System Control
\item CPU Control
\item CPU Bus Control
\end{itemize}

\paragraph{System Control}

Umfasst M1, MREQ, IORQ, RD, WR und RFSH.\\

\begin{tabularx}{\textwidth}{|l|X|}
\hline
Signal & Bedeutung \\
\hline
M1 & Mit diesem Signal meldet die CPU, dass sie sich im Befehlsholzyklus befindet. Falls IORQ aktiv ist, dient es zur Interruptquittierung seitens der CPU. \\
MREQ & Zeigt eine Speicheroperation der CPU an. \\
IORQ & Kennzeichnet Datenverkehr zwischen CPU und dem durch den Adressbus adressieren E/A-Ger"at. \\
RD & Zeigt an, dass auf dem Speicher oder Peripherie Leseoperation ausgef"uhrt wird\\
WR & Ist aktiv, wenn der Datenbus g"ultige Daten f"ur eine Schreiboperation enth"alt. \\
RFSH & Falls es aktiv ist, bedeutet dies, dass die niederwertigsten Bits eine Refresh-Adresse f"ur dynamische Speicher benutzten\\
\hline
\end{tabularx}

\paragraph{CPU Control}
\label{sec:cpu_control}

Umfasst HALT, WAIT, INT, NMI und RESET.\\

\begin{tabularx}{\textwidth}{|l|X|}
\hline
Signal & Bedeutung \\
\hline
HALT & Kennzeichnet, dass CPU einen Halt-Befehl ausgef"uhrt hat. Zur Erl"auterung des HALT-Zustands, siehe  Abschnitt \ref{sec:halt_antwort}. \\
WAIT & Erlaubt das Einf"ugen von Wartezyklen in die Lese- und Schreibzyklen der CPU mit dem Speicher und den E/A-Einheiten. Es dient somit zur Synchronisation mit diesen. Wenn das Signal aktiv ist, zeigt dieses an, dass der angesprochene Speicher bzw. E/A-Baustein noch nicht bereit zur Daten"ubertragung ist \\
INT & Zur Bedeutung siehe Abschnitt \ref{sec:interrupt_antwort}. Es wird ein Interrupt ausgel"ost, sofern dieser freigegeben ist und BUSRQ \emph{nicht} aktiv ist. \\
NMI & Zur Bedeutung vergleiche Abschnitt \ref{sec:interrupt_antwort}. L"ost einen nicht maskierbaren Interrupt aus. \\
RESET & Bringt den Prozessor in den Anfangszustand. \\
\hline
\end{tabularx}

\paragraph{CPU Bus Control}

Die CPU Bus Control Signale dienen zur Anforderung des Buses für den DMA-Betrieb. Sie umfassen BUSRQ und BUSACK.
\\

\begin{tabularx}{\textwidth}{|l|X|}
\hline
Signal & Bedeutung \\
\hline
BUSRQ & Dieses Signal wird von einer Einheit geliefert, um DMA-Betrieb anzumelden, also zur Anforderung des CPU-Bussystems. \\
BUSACK & Mit diesem Signal quittiert die CPU die Anmeldung eines BUSRQ. Der Datenverkehr kann somit von einer DMA-Einheit gesteuert werden. \\
\hline
\end{tabularx}

\subsection{Interrupt}

\subsubsection{Frage}

Was ist ein Interrupt?

\subsubsection{Antwort}
\label{sec:interrupt_antwort}

Ein Interrupt ist eine asynchrone Unterbrechung eines gerade ausgef"uhrten Programms, damit der Prozessor auf bestimmte Forderungen reagieren kann. Gegen"uber einer zyklischen Abfrage (Polling) wird Zeit eingespart.

Interrupts erm"oglichen au"serdem die parallele Abarbeitung mehrerer Programme durch eine CPU, indem man durch Interrupts und geeignete Priorisierung die CPU auf die zu einem Zeitpunkt wichtigste Aufgabe lenkt (vgl. \cite[S.~70]{KieserMeder86}).

\subsection{Interruptmodi}

\subsubsection{Frage}

Erläutern Sie die drei möglichen Interruptmodi der Z 80 CPU!

\subsubsection{Antwort}
\label{sec:interruptmodi_antwort}

F"ur den maskierbaren Interrupt werden 3 Modi unterschieden (vgl. \cite[S.~75]{KieserMeder86}):

\paragraph{IM0} Das von der unterbrechenden Einheit auf dem Datenbus platzierte Wort wird als \emph{Befehl} betrachtet und ausgef"uhrt. 

\paragraph{IM1} Wenn INT anliegt, erfolgt ein Sprung zur Adresse \verb|0038h|. Dies ist "ahnlich dem NMI -- nur wird dort die Adresse \verb|0066h| verwendet.

\paragraph{IM2} Bei Anwendung dieses Modus baut der Programmierer eine Interruptvektor-Tabelle mit den Anfangsadressen der Interrupt-Service-Routinen (ISR) auf. Jede dieser Adressen umfasst 2 Bytes -- daher ist das von der unterbrechenden Einheit gelieferte Byte gerade. Dieses Byte bildet das untere Byte der Startadresse der ISR. Das obere Byte liefert das I-Register.

\subsection{Nichtmaskierbare vs. maskierbare Interrupts}

\subsubsection{Frage}

Erläutern Sie den Unterschied zwischen nichtmaskierbaren Interrupts (NMI) und
einem maskierbaren Interrupt!

\subsubsection{Antwort}

Laut \cite[S.~70]{KieserMeder86} besitzt die Z 80 CPU zwei Interrupteing"ange: INT und NMI.

Der nichtmaskierbare Interrupt (NMI) besitzt die höhere Priorit"at und kann nicht per Programm gesperrt werden. Daher unterbricht die CPU das laufende Programm ausnahmslos, falls dieser Interrupt anliegt. Aus diesem Grund ist dieser im Allgemeinen f"ur sehr wichtige Ereignisse, wie Ausf"alle, Havarien und andere nicht vorhersehbare Ereignisse reserviert.

Der maskierbare Interrupt (INT) kann dagegen gezielt per Programm gesperrt und freigegeben werden. Eine Sperrung kann beispielsweise dann notwendig sein, wenn zwar eine Interruptserviceroutine niedriger Priorit"at abl"auft, aber eine Unterbrechung bestimmter Programmteile aufgrund des geforderten Echtzeitverhaltens nicht tragbar ist. In diesem Fall sperrt man in diesem Programmteil den maskierbaren Interrupt.

Nach einem Reset der CPU ist die Verarbeitung des maskierbaren Interrupts gesperrt. Durch den Befehl EI (enable interrupt) wird diese Sperre aufgehoben und durch DI (disable interrupt) gesetzt. 

\subsection{HALT-Zustand}

\subsubsection{Frage}

Wodurch ist der HALT-Zustand der Z 80 CPU gekennzeichnet?

\subsubsection{Antwort}
\label{sec:halt_antwort}

Laut ~\cite[S.~34]{KieserMeder86} ist der HALT-Zustand dadurch charakterisiert, dass während sich die CPU in diesem Zustand befindt, NOP-Befehle ausgeführt werden, deren Zweck der Refresh dynamischer Speicher ist.

Der HALT-Zustand kann von der CPU nur verlassen werden, wenn ein INT- oder NMI-Signal best"atigt wird.

\subsection{Adressbereich}

\subsubsection{Frage}

Wie groß ist der Adressbereich für anschließbare Speicher und Ein-/Ausgabe-Tore
der Z 80 CPU?

\subsubsection{Antwort}

Da 16 Adressleitungen zur Verf"ugung stehen, ist der Speicherbereich prinzipiell bis zu $2^{16}~\textnormal{Byte}=65536~\textnormal{Byte}=64~KiB$ groß.

\subsection{Bidirektionaler Datentransfer}

\subsubsection{Frage}

Was bedeutet bidirektionaler Datentransfer?

\subsubsection{Antwort}

Laut ~\cite[S.~348]{KieserMeder86} versteht man unter einem bidirektionalen Datentransfer einen zeitmultiplexen Zweirichtungsbetrieb zur Signal"ubertragung.

\section{Versuchsaufgaben}

Als Notation zur Beantwortung der Aufgaben wollen wir Folgendes vereinbaren: wenn hinter einem Wert im Datenbus-Feld ein ${}^*$ erscheint, so soll dies bedeuten, dass der Wert in diesem Takt manuell durch uns auf den Wert gesetzt wurde.

\subsection{M1-Zyklus}

\subsubsection{Aufgabe}

Stellen Sie die für diesen Zyklus signifikanten Signale über den Taktimpulsen grafisch dar.
Überprüfen Sie die Wirkung der WAIT-, RESET- und BUSRQ-Signale.

\subsubsection{L"osung}

Es wird ein 00 (NOP) auf den Datenbus gelegt.

Zuerst führen wir das Programm aus, ohne das WAIT-, RESET- oder BUSRQ-Signal zu aktivieren.

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
1 & M1, MREQ, RD & \verb|0000| & \verb|00|${}^*$ \\
2 & M1, MREQ, RD & \verb|0000| & \verb|00|${}^*$ \\
3 & MREQ, RFSH & \verb|0000| & \verb|FF| \\
4 & RFSH & \verb|0000| & \verb|FF| \\
5 & M1, MREQ, RD & \verb|0001| & \verb|00|${}^*$ \\
\hline
\end{tabular}
\\

Nun aktivieren wir in diesem Takt das WAIT-Signal:

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
5 & M1, MREQ, RD, WAIT & \verb|0001| & \verb|00|${}^*$ \\
6 & M1, MREQ, RD, WAIT & \verb|0001| & \verb|00|${}^*$ \\
7 & M1, MREQ, RD, WAIT & \verb|0001| & \verb|00|${}^*$ \\
8 & M1, MREQ, RD, WAIT & \verb|0001| & \verb|00|${}^*$ \\
9 & M1, MREQ, RD, WAIT & \verb|0001| & \verb|00|${}^*$ \\
\hline
\end{tabular}
\\

Wie man sieht, führt dies dazu, dass -- wie in Abschnitt \ref{sec:cpu_control} beschrieben -- die CPU Wartezyklen einf"ugt, da das Signal anzeigt, dass der Speicher bzw. das E/A-Ger"at noch nicht bereit ist.

Als folgenden Schritt deaktivieren wir WAIT und aktivieren RESET:

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
9 & M1, MREQ, RD, RESET & \verb|0001| & \verb|00|${}^*$ \\
10 & M1, MREQ, RD, RESET & \verb|0001| & \verb|00|${}^*$ \\
11 & MREQ, RFSH, RESET & \verb|0001| & \verb|FF| \\
12 & RESET & \verb|FFFF| & \verb|FF| \\
13 & RESET & \verb|FFFF| & \verb|FF| \\
14 & RESET & \verb|FFFF| & \verb|FF| \\
\hline
\end{tabular}
\\

Nun deaktivieren wir wieder RESET:

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
14 & - & \verb|FFFF| & \verb|FF| \\
15 & - & \verb|FFFF| & \verb|FF| \\
16 & - & \verb|FFFF| & \verb|FF| \\
17 & - & \verb|FFFF| & \verb|FF| \\
18 & M1, MREQ, RD & \verb|0000| & $31$ \\
\hline
\end{tabular}
\\

Die 31, die in Takt 18 auf dem Datenbus liegt, ist der nach dem Reset vorliegende, zufällige Wert der Speicherzelle \verb|0000|.

Nun zum BUSREQ-Signal:

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
18 & M1, MREQ, RD, BUSREQ & \verb|0000| & \verb|00|${}^*$ \\
19 & M1, MREQ, RD, BUSREQ & \verb|0000| & \verb|00|${}^*$ \\
20 & MREQ, RFSH, BUSREQ & \verb|0000| & \verb|FF| \\
21 & RFSH, BUSREQ & \verb|0001| & \verb|FF| \\
22 & BUSREQ, BUSACK & \verb|FFFF| & \verb|FF| \\
23 & BUSREQ, BUSACK & \verb|FFFF| & \verb|FF| \\
24 & BUSREQ, BUSACK & \verb|FFFF| & \verb|FF| \\
\hline
\end{tabular}
\\

Nun deaktivieren wir wieder BUSREQ:

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
24 & BUSACK & \verb|FFFF| & \verb|FF| \\
25 & - & \verb|FFFF| & \verb|FF| \\
26 & M1, MREQ, RD & \verb|0001| & \verb|00|${}^*$ \\
\hline
\end{tabular}

\subsection{Speicher-Lese-/Schreib-Zyklus}

\subsubsection{Aufgabe}

Nehmen Sie entsprechend o. a. Muster das Zyklusdiagramm für einen Speicher-Lese-/Schreib-
Zyklus auf.

\subsubsection{L"osung}

Wir nutzen den Befehl \verb|LD A, n| mit n=\verb|42h| (\verb|3E 42|), um in den Akkumulator den Wert \verb|42h| zu laden:

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
1 & M1, MREQ, RD & \verb|0000| & \verb|3E|${}^*$ \\
2 & M1, MREQ, RD & \verb|0000| & \verb|3E|${}^*$ \\
3 & MREQ, RFSH & \verb|0000| & \verb|FF| \\
4 & RFSH & \verb|0000| & \verb|FF| \\
5 & MREQ, RD & \verb|0001| & \verb|42|${}^*$ \\
6 & MREQ, RD & \verb|0001| & \verb|42|${}^*$ \\
7 & - & \verb|0001| & \verb|FF| \\
\hline
\end{tabular}
\\

Nun nutzen wir den Befehl "`LD (n, n), A"' mit (n, n)=\verb|8000h| (\verb|32 00 80|), um den Wert des Akkumulators (\verb|42h|) in der Speicheradresse \verb|8000h| abzulegen:

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
8 & M1, MREQ, RD & \verb|0002| & \verb|32|${}^*$ \\
9 & M1, MREQ, RD & \verb|0000| & \verb|32|${}^*$ \\
10 & MREQ, RFSH & \verb|0001| & \verb|FF| \\
11 & RFSH & \verb|0001| & \verb|FF| \\
12 & MREQ, RD & \verb|0003| & \verb|00|${}^*$ \\
13 & MREQ, RD & \verb|0003| & \verb|00|${}^*$ \\
14 & - & \verb|0003| & \verb|FF| \\
15 & MREQ, RD & \verb|0004| & \verb|80|${}^*$ \\
16 & MREQ, RD & \verb|0004| & \verb|80|${}^*$ \\
17 & - & \verb|0003| & \verb|FF| \\
18 & MREQ & \verb|8000| & 42 \\
19 & MREQ, WR & \verb|8000| & 42 \\
20 & - & \verb|8000| & 42 \\
\hline
\end{tabular}
\\

Im Folgenden lesen wir den Wert der Speicherzelle \verb|8000h| wieder aus -- dies geschieht mit dem Befehl "`LD A, (n, n)"' (\verb|3A 00 80|):

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
21 & M1, MREQ, RD & \verb|0005| & \verb|3A|${}^*$ \\
22 & M1, MREQ, RD & \verb|0005| & \verb|3A|${}^*$ \\
23 & MREQ, RFSH & \verb|0002| & \verb|FF| \\
24 & RFSH & \verb|0002| & \verb|FF| \\
25 & MREQ, RD & \verb|0006| & \verb|00|${}^*$ \\
26 & MREQ, RD & \verb|0006| & \verb|00|${}^*$ \\
27 & - & \verb|0006| & \verb|FF| \\
28 & MREQ, RD & \verb|0007| & \verb|80|${}^*$ \\
29 & MREQ, RD & \verb|0007| & \verb|80|${}^*$ \\
30 & - & \verb|0007| & \verb|FF| \\
31 & MREQ, RD & \verb|8000| & 42 \\
32 & MREQ, RD & \verb|8000| & 42 \\
33 & - & \verb|8000| & FF \\
34 & M1, MREQ, RD & \verb|0008| & \verb|00|${}^*$ \\
\hline
\end{tabular}
\\

\subsection{E/A-Zyklus}

\subsubsection{Aufgabe}

Programmieren Sie einen E/A-Zyklus und nehmen Sie das Zyklus-Diagramms auf. Halten Sie
die Inhalte des Adress- und Datenbusses schriftlich fest.

\subsubsection{L"osung}

Analog zur vorherigen Aufgabe speichern wir diesmal \verb|56h| im Akkumulator:

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
1 & M1, MREQ, RD & \verb|0000| & \verb|3E|${}^*$ \\
2 & M1, MREQ, RD & \verb|0000| & \verb|3E|${}^*$ \\
3 & MREQ, RFSH & \verb|0000| & \verb|FF| \\
4 & RFSH & \verb|0000| & \verb|FF| \\
5 & MREQ, RD & \verb|0001| & \verb|42|${}^*$ \\
6 & MREQ, RD & \verb|0001| & \verb|42|${}^*$ \\
7 & - & \verb|0001| & \verb|FF| \\
\hline
\end{tabular}
\\

Nun benutzen wir den Befehl \verb|OUT n| mit n=\verb|67h| (\verb|D3 67|), um den Wert des Akkumulators auf Port \verb|67h| auszugeben:

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
8 & M1, MREQ, RD & \verb|0002| & \verb|D3|${}^*$ \\
9 & M1, MREQ, RD & \verb|0002| & \verb|D3|${}^*$ \\
10 & MREQ, RFSH & \verb|0001| & \verb|FF| \\
11 & RFSH & \verb|0001| & \verb|FF| \\
12 & MREQ, RD & \verb|0003| & \verb|67|${}^*$ \\
13 & MREQ, RD & \verb|0003| & \verb|67|${}^*$ \\
14 & - & \verb|0003| & \verb|FF| \\
15 & - & \verb|5667| & \verb|56| \\
16 & IORQ, WR & \verb|5667| & \verb|56| \\
17 & IORQ, WR & \verb|5667| & \verb|56| \\
18 & - & \verb|5667| & \verb|56| \\
\hline
\end{tabular}
\\

Zu der letzten Zeilen eine Bemerkung: es gibt nur 256 Ports, jedoch hat der Adressbus 16 Bits. Daher wird nur das untere Byte des Adressbusses verwendet -- im oberen d"urfte ein beliebiger Wert stehen, da er ignoriert wird. In der Praxis wird im oberen Byte der Wert des Akkumulators gesendet.

Nun zum Lesen aus einem Port (wir haben uns f"ur Port \verb|13h| entschieden): hierf"ur gibt es den Befehl \verb|IN n| (f"ur genanntes n=\verb|13h| ist es \verb|DB 13|).

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
19 & M1, MREQ, RD & \verb|0004| & \verb|DB|${}^*$ \\
20 & M1, MREQ, RD & \verb|0004| & \verb|DB|${}^*$ \\
21 & MREQ, RFSH & \verb|0002| & \verb|FF| \\
22 & RFSH & \verb|0002| & \verb|FF| \\
23 & MREQ, RD & \verb|0005| & \verb|13|${}^*$ \\
24 & MREQ, RD & \verb|0005| & \verb|13|${}^*$ \\
25 & - & \verb|0005| & \verb|FF| \\
26 & - & \verb|5613| & \verb|FF| \\
27 & IORQ, RD & \verb|5613| & \verb|FF| \\
28 & IORQ, RD & \verb|5613| & \verb|FF| \\
29 & - & \verb|5667| & \verb|FF| \\
30 & M1, MREQ, RD & \verb|0006| & \verb|00|${}^*$ \\
\hline
\end{tabular}
\\

Da kein Gerät an Port \verb|13h| angeschlossen ist, wird in den Takten 26 bis 28 auf dem Datenbus nur \verb|FF| "ubertragen. Wir h"atten mittels des Kontrollpanels den auf dem Datenbus übertragenen Wert "andern k"onnen, haben jedoch keinen Gebrauch davon gemacht.

\subsection{Interruptbehandlungszyklus}

\subsubsection{Aufgabe}

Nehmen Sie das Zyklusdiagramm auf und charakterisieren Sie die Unterschiede zu einem
normalen M1-Zyklus!

\subparagraph{Hinweis} Vor Beginn ist das Interruptfreigabe-Flip-Flop durch einen entsprechenden Befehl
zu setzten!

\subsubsection{L"osung}

\label{sec:int_lsg}

Wie im Hinweis vorgegeben, m"ussen wir als ersten Schritt die Interrupts freigeben. Dies geschieht mit dem \verb|EI|-Befehl (\verb|FBh|):

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
1 & M1, MREQ, RD & \verb|0000| & \verb|FB|${}^*$ \\
2 & M1, MREQ, RD & \verb|0000| & \verb|FB|${}^*$ \\
3 & MREQ, RFSH & \verb|0000| & \verb|FF| \\
4 & RFSH & \verb|0000| & \verb|FF| \\
\hline
\end{tabular}
\\

Anschließend setzen wir den Interruptmodus auf 1 durch den Befehl \verb|IM1| (\verb|ED 56h|).

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
5 & M1, MREQ, RD & \verb|0001| & \verb|ED|${}^*$ \\
6 & M1, MREQ, RD & \verb|0001| & \verb|ED|${}^*$ \\
7 & MREQ, RFSH & \verb|0001| & \verb|FF| \\
8 & RFSH & \verb|0001| & \verb|FF| \\
9 & M1, MREQ, RD & \verb|0002| & \verb|56|${}^*$ \\
10 & M1, MREQ, RD & \verb|0002| & \verb|56|${}^*$ \\
11 & MREQ, RFSH & \verb|0002| & \verb|FF| \\
12 & RFSH & \verb|0002| & \verb|FF| \\
\hline
\end{tabular}
\\

Nun legen wir einen \verb|NOP|-Befehl (\verb|00h|), der als Auswirkung nur den Program Counter erhöht, auf  den Datenbus und aktivieren Interrupts.

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
13 & M1, MREQ, RD, INT & \verb|0003| & \verb|00|${}^*$ \\
14 & M1, MREQ, RD, INT & \verb|0003| & \verb|00|${}^*$ \\
15 & MREQ, RFSH, INT & \verb|0003| & \verb|FF| \\
16 & RFSH, INT & \verb|0003| & \verb|FF| \\
17 & M1, INT & \verb|0004| & \verb|FF| \\
18 & M1, INT & \verb|0004| & \verb|FF| \\
\hline
\end{tabular}
\\

Wie man sieht, wird der aktuelle Befehl noch fertig abgearbeitet und anschließend mit der Interruptverarbeitung begonnen.

Im folgenden Schritt liefert die unterbrechende Einheit ein Byte auf den Datenbus. Im gewählten IM1-Modus spielt dieses jedoch -- wie in Abschnitt \ref{sec:interruptmodi_antwort} beschrieben -- keine weitere Rolle.  Wir haben f"ur dieses Byte den Wert \verb|12h| verwendet.

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
19 & M1, IORQ, INT  & \verb|0004| & \verb|12|${}^*$ \\
20 & M1, IORQ, INT & \verb|0004| & \verb|12|${}^*$ \\
21 & MEMRQ, RFSH, INT & \verb|0004| & \verb|FF| \\
22 & RFSH, INT & \verb|0004| & \verb|FF| \\
23 & INT & \verb|0004| & \verb|FF| \\
\hline
\end{tabular}
\\

Nun wird der Wert des Program Counters auf den Stack gelegt.

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
24 & MREQ, INT  & \verb|FFFA| & \verb|00| \\
25 & MREQ, WR, INT & \verb|FFFA| & \verb|00| \\
26 & INT & \verb|FFFA| & \verb|00| \\
27 & MREQ, INT & \verb|FFF9| & \verb|04| \\
28 & MREQ, WR, INT & \verb|FFF9| & \verb|04| \\
29 & INT & \verb|FFF9| & \verb|04| \\
\hline
\end{tabular}
\\

Anschließend wird in die Interrupt Service Routine gesprungen, die im IM1-Modus auf der Adresse \verb|00 38h| im Speicher liegt. Gleichzeitig haben wir uns entschieden von nun an das INT-Signal wieder auszuschalten.

Der Befehl, welchen wir ausf"uhren, ist \verb|RETI| (\verb|ED 4Dh|), welcher daf"ur sorgt, dass die Interrupt Service Routine eines maskierbaren Interrupts verlassen wird und der Programmablauf regul"ar fortgesetzt wird.

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
30 & M1, MREQ, RD  & \verb|0038| & \verb|ED|${}^*$ \\
31 & M1, MREQ, RD & \verb|0038| & \verb|ED|${}^*$ \\
32 & MREQ, RFSH & \verb|0005| & \verb|FF| \\
33 & RFSH & \verb|0005| & \verb|FF| \\
34 & M1, MREQ, RD  & \verb|0039| & \verb|4D|${}^*$ \\
35 & M1, MREQ, RD & \verb|0039| & \verb|4D|${}^*$ \\
36 & MREQ, RFSH & \verb|0006| & \verb|FF| \\
37 & RFSH & \verb|0006| & \verb|FF| \\
\hline
\end{tabular}
\\

Nun wird der vorherige Wert des Program Counters vom Stack zur"uckgeholt und anschließend das Programm an der Speicheradresse \verb|00 04h| fortgesetzt. Zur "Uberpr"ufung f"uhren wir am Ende noch einen NOP-Befehl an dieser Adresse aus.

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
38 & MREQ, RD  & \verb|FFF9| & \verb|04| \\
39 & MREQ, RD & \verb|FFF9| & \verb|04| \\
40 & - & \verb|FFF9| & \verb|FF| \\
41 & MREQ, RD & \verb|FFFA| & \verb|00| \\
42 & MREQ, RD & \verb|FFFA| & \verb|00| \\
43 & - & \verb|FFFA| & \verb|FF| \\
44 & M1, MREQ, RD & \verb|0004| & \verb|00|${}^*$ \\
45 & M1, MREQ, RD & \verb|0004| & \verb|00|${}^*$ \\
46 & MREQ, RFSH & \verb|0007| & \verb|FF| \\
47 & RFSH & \verb|0007| & \verb|FF| \\
48 & M1, MREQ, RD & \verb|0005| & \verb|00|${}^*$ \\
\hline
\end{tabular}
\\

\subsection{NMI-Routine}

\subsubsection{Aufgabe}

Setzten Sie während eines M1-Zyklus ein NMI-Signal und halten Sie den weiteren Verlauf
fest!

\subsubsection{L"osung}

\label{sec:nmi_lsg}

Analog zur vorhergehenden Aufgabe schalten wir in den IM1-Modus (nachtr"aglich stellten wir fest, dass dies "uberfl"ussig ist, da die unterschiedlichen Interrupt-Modi nur beim maskierbaren Interrupt unterschieden werden).

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
1 & M1, MREQ, RD & \verb|0000| & \verb|ED|${}^*$ \\
2 & M1, MREQ, RD & \verb|0000| & \verb|ED|${}^*$ \\
3 & MREQ, RFSH & \verb|0000| & \verb|FF| \\
4 & RFSH & \verb|0000| & \verb|FF| \\
5 & M1, MREQ, RD & \verb|0001| & \verb|56|${}^*$ \\
6 & M1, MREQ, RD & \verb|0001| & \verb|56|${}^*$ \\
7 & MREQ, RFSH & \verb|0001| & \verb|FF| \\
8 & RFSH & \verb|0001| & \verb|FF| \\
\hline
\end{tabular}
\\

W"ahrend wir in der vorhergehenden Aufgabe vor dem ersten M1-Signal das Interrupt-Signal angelegt haben, legen wir es diesmal erst beim zweiten M1 eines Befehls an, um zu sehen, dass dieser Befehl dann noch fertig ausgef"uhrt wird.

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
9 & M1, MREQ, RD & \verb|0002| & \verb|00|${}^*$ \\
10 & M1, MREQ, RD, NMI & \verb|0002| & \verb|00|${}^*$ \\
11 & MREQ, RFSH, NMI & \verb|0002| & \verb|FF| \\
12 & RFSH, NMI & \verb|0002| & \verb|FF| \\
13 & M1, MREQ, RD, NMI & \verb|0003| & \verb|56|${}^*$ \\
14 & M1, MREQ, RD, NMI & \verb|0003| & \verb|56|${}^*$ \\
15 & MREQ, RFSH, NMI & \verb|0003| & \verb|FF| \\
16 & RFSH, NMI & \verb|0003| & \verb|FF| \\
17 & NMI & \verb|0003| & \verb|FF| \\
\hline
\end{tabular}
\\

Anschließend wird der Wert des Program Counters auf dem Stack gesichert und in die Interrupt Service Routine des nicht maskierbaren Interrupts gesprungen -- diese befindet sich an der Adresse \verb|0066|.

Wir merken an, dass wir ab Zeile 19 das NMI-Signal wieder ausgeschaltet haben.

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
18 & MREQ, NMI  & \verb|FFFA| & \verb|00| \\
19 & MREQ, WR & \verb|FFFA| & \verb|00| \\
20 & - & \verb|FFFA| & \verb|00| \\
21 & MREQ & \verb|FFF9| & \verb|03| \\
22 & MREQ, WR & \verb|FFF9| & \verb|03| \\
23 & - & \verb|FFF9| & \verb|03| \\
\hline
\end{tabular}
\\

Diesmal benutzen wir den Befehl \verb|RETN| (\verb|ED 45|), um die Service Routine des NMI zu beenden.

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
24 & M1, MREQ, RD  & \verb|0066| & \verb|ED|${}^*$ \\
25 & M1, MREQ, RD & \verb|0066| & \verb|ED|${}^*$ \\
26 & MREQ, RFSH & \verb|0004| & \verb|FF| \\
27 & RFSH & \verb|0004| & \verb|FF| \\
28 & M1, MREQ, RD  & \verb|0067| & \verb|45|${}^*$ \\
29 & M1, MREQ, RD & \verb|0067| & \verb|45|${}^*$ \\
30 & MREQ, RFSH & \verb|0005| & \verb|FF| \\
31 & RFSH & \verb|0005| & \verb|FF| \\
\hline
\end{tabular}
\\

Nun wird -- wie bereits in der vorherigen Aufgabe betrachtet -- der Program Counter vom Stack geholt und das Programm an dieser Stelle fortgesetzt. Auch hier haben wir zu Testzwecken einen NOP-Befehl eingef"ugt.

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
32 & MREQ  & \verb|FFF9| & \verb|03| \\
33 & MREQ, RD & \verb|FFF9| & \verb|03| \\
34 & - & \verb|FFF9| & \verb|FF| \\
35 & MREQ & \verb|FFFA| & \verb|00| \\
36 & MREQ, RD & \verb|FFFA| & \verb|00| \\
37 & - & \verb|FFFA| & \verb|FF| \\
38 & M1, MREQ, RD & \verb|0003| & \verb|00|${}^*$ \\
39 & M1, MREQ, RD & \verb|0003| & \verb|00|${}^*$ \\
40 & MREQ, RFSH & \verb|0006| & \verb|FF| \\
41 & RFSH & \verb|0006| & \verb|FF| \\
42 & M1, MREQ, RD & \verb|0004| & \verb|00|${}^*$ \\
\hline
\end{tabular}
\\

\subsection{HALT-Zustand}

\subsubsection{Aufgabe}

Programmieren Sie einen Software-HALT und setzen Sie das Programm mit den vorhandenen
Möglichkeiten fort.

\subsubsection{L"osung}

Da in der Aufgabenstellung explizit von \emph{den} vorhandenen Möglichkeiten gesprochen wurde, sind wir auf zwei Möglichkeiten eingegangen:

\begin{itemize}
\item Unter Verwendung eines NMI
\item Unter Verwendung eines maskierbaren Interrupts (sofern dieser freigeschalten wurde)
\end{itemize}

\paragraph{Programmfortsetzung unter Verwendung eines NMI} ~\\

In den ersten acht Schritten setzen wir wie bereits in Abschnitt \label{sec:nmi_lsg} beschrieben und dort als "uberfl"ussig erkannt, den Interruptmodus auf IM1:

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
1 & M1, MREQ, RD & \verb|0000| & \verb|ED|${}^*$ \\
2 & M1, MREQ, RD & \verb|0000| & \verb|ED|${}^*$ \\
3 & MREQ, RFSH & \verb|0000| & \verb|FF| \\
4 & RFSH & \verb|0000| & \verb|FF| \\
5 & M1, MREQ, RD & \verb|0001| & \verb|56|${}^*$ \\
6 & M1, MREQ, RD & \verb|0001| & \verb|56|${}^*$ \\
7 & MREQ, RFSH & \verb|0001| & \verb|FF| \\
8 & RFSH & \verb|0001| & \verb|FF| \\
\hline
\end{tabular}
\\

Als folgenden Schritt f"uhren wir das gefordete \verb|HALT| (\verb|76h|) aus:

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
9 & M1, MREQ, RD & \verb|0002| & \verb|76|${}^*$ \\
10 & M1, MREQ, RD & \verb|0002| & \verb|76|${}^*$ \\
11 & MREQ, RFSH & \verb|0002| & \verb|FF| \\
12 & RFSH, HALT & \verb|0002| & \verb|FF| \\
13 & M1, MREQ, RD, HALT & \verb|0003| & \verb|00|${}^*$ \\
14 & M1, MREQ, RD, HALT & \verb|0003| & \verb|00|${}^*$ \\
15 & MREQ, RFSH, HALT & \verb|0003| & \verb|FF| \\
16 & MREQ, RFSH, HALT & \verb|0003| & \verb|FF| \\
17 & M1, MREQ, RD, HALT & \verb|0003| & \verb|00|${}^*$ \\
\hline
\end{tabular}
\\

Wie man sieht, f"uhrt der Prozessor im HALT-Zustand keine weiteren Befehle aus. Um den Modus zu verlassen, aktivieren wir in Takt 17 einen NMI:

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
17 & M1, MREQ, RD, HALT, NMI & \verb|0003| & \verb|00|${}^*$ \\
18 & M1, MREQ, RD, HALT, NMI & \verb|0003| & \verb|00|${}^*$ \\
19 & MREQ, RFSH, HALT, NMI & \verb|0004| & \verb|FF|${}^*$ \\
20 & RFSH, NMI & \verb|0004| & \verb|FF|${}^*$ \\
\hline
\end{tabular}
\\

Wie man in Takt 20 sieht, wird der HALT-Zustand verlassen.

Nun ist im Folgenden das Ziel nach dem Betreten der Interrupt Service Routine ein \verb|RETN| abzusetzen, um diese wie in Abschnitt \label{sec:nmi_lsg} zu verlassen.



\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
21 & M1, RFSH, HALT, NMI & \verb|0003| & \verb|00| \\
22 & M1, RFSH, HALT, NMI & \verb|0003| & \verb|00| \\
23 & MREQ, RFSH, NMI & \verb|0005| & \verb|FF| \\
24 & RFSH, NMI & \verb|0005| & \verb|FF| \\
25 & NMI & \verb|0005| & \verb|FF| \\
26 & MREQ, NMI  & \verb|FFFA| & \verb|00| \\
27 & MREQ, WR & \verb|FFFA| & \verb|00| \\
28 & - & \verb|FFFA| & \verb|00| \\
29 & MREQ & \verb|FFF9| & \verb|03| \\
30 & MREQ, WR & \verb|FFF9| & \verb|03| \\
31 & - & \verb|FFF9| & \verb|03| \\
32 & M1, MREQ, RD  & \verb|0066| & \verb|ED|${}^*$ \\
33 & M1, MREQ, RD & \verb|0066| & \verb|ED|${}^*$ \\
34 & MREQ, RFSH & \verb|0006| & \verb|FF| \\
35 & RFSH & \verb|0006| & \verb|FF| \\
36 & M1, MREQ, RD  & \verb|0067| & \verb|45|${}^*$ \\
37 & M1, MREQ, RD & \verb|0067| & \verb|45|${}^*$ \\
38 & MREQ, RFSH & \verb|0007| & \verb|FF| \\
39 & RFSH & \verb|0007| & \verb|FF| \\
40 & MREQ  & \verb|FFF9| & \verb|03| \\
41 & MREQ, RD & \verb|FFF9| & \verb|03| \\
42 & - & \verb|FFF9| & \verb|FF| \\
43 & MREQ & \verb|FFFA| & \verb|00| \\
44 & MREQ, RD & \verb|FFFA| & \verb|00| \\
45 & - & \verb|FFFA| & \verb|FF| \\
46 & M1, MREQ, RD & \verb|0003| & \verb|00|${}^*$ \\
47 & M1, MREQ, RD & \verb|0003| & \verb|00|${}^*$ \\
48 & MREQ, RFSH & \verb|0008| & \verb|FF| \\
49 & RFSH & \verb|0008| & \verb|FF| \\
50 & M1, MREQ, RD & \verb|0004| & \verb|00|${}^*$ \\
\hline
\end{tabular}

\paragraph{Programmfortsetzung unter Verwendung eines maskierbaren Interrupts} ~\\

Hierfür ist es Voraussetzung, dass wir den maskierbaren Interrupt aktiviert haben. Zudem setzen wir den Prozessor in den IM1-Modus, um sp"ater komfortabel den \verb|RETI|-Befehl absetzen zu k"onnen.


\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
1 & M1, MREQ, RD & \verb|0000| & \verb|FB|${}^*$ \\
2 & M1, MREQ, RD & \verb|0000| & \verb|FB|${}^*$ \\
3 & MREQ, RFSH & \verb|0000| & \verb|FF| \\
4 & RFSH & \verb|0000| & \verb|FF| \\
5 & M1, MREQ, RD & \verb|0001| & \verb|ED|${}^*$ \\
6 & M1, MREQ, RD & \verb|0001| & \verb|ED|${}^*$ \\
7 & MREQ, RFSH & \verb|0001| & \verb|FF| \\
8 & RFSH & \verb|0001| & \verb|FF| \\
9 & M1, MREQ, RD & \verb|0002| & \verb|56|${}^*$ \\
10 & M1, MREQ, RD & \verb|0002| & \verb|56|${}^*$ \\
11 & MREQ, RFSH & \verb|0002| & \verb|FF| \\
12 & RFSH & \verb|0002| & \verb|FF| \\
\hline
\end{tabular}
\\

Nun führen wir wieder den \verb|HALT|-Befehl aus, aktivieren anschließend den maskierbaren Interrupt INT und f"uhren ein \verb|RETI| aus, um die Interrupt Service Routine zu verlassen und das Programm regul"ar fortzusetzen.

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
13 & M1, MREQ, RD & \verb|0003| & \verb|76|${}^*$ \\
14 & M1, MREQ, RD & \verb|0003| & \verb|76|${}^*$ \\
15 & MREQ, RFSH & \verb|0003| & \verb|FF| \\
16 & RFSH & \verb|0003| & \verb|FF| \\
17 & M1, MREQ, RD, HALT & \verb|0004| & \verb|00|${}^*$ \\
18 & M1, MREQ, RD, HALT & \verb|0004| & \verb|00|${}^*$ \\
19 & MREQ, RFSH, HALT & \verb|0004| & \verb|FF| \\
20 & RFSH, HALT & \verb|0004| & \verb|FF| \\
21 & M1, MREQ, RD, HALT, INT & \verb|0004| & \verb|00|${}^*$ \\
22 & M1, MREQ, RD, HALT, INT & \verb|0004| & \verb|00|${}^*$ \\
23 & MREQ, RFSH, HALT, INT & \verb|0005| & \verb|FF|  \\
24 & RFSH, INT & \verb|0005| & \verb|FF|  \\
25 & M1, INT & \verb|0004| & \verb|FF|  \\
26 & M1, INT & \verb|0004| & \verb|FF|  \\
27 & M1, IORQ, INT & \verb|0006| & \verb|FF| \\
28 & M1, IORQ, INT & \verb|0006| & \verb|FF| \\
29 & MREQ, RFSH & \verb|0006| & \verb|FF|  \\
30 & RFSH & \verb|0006| & \verb|FF|  \\
31 & - & \verb|0006| & \verb|FF| \\
32 & MREQ  & \verb|FFFA| & \verb|00| \\
33 & MREQ, WR & \verb|FFFA| & \verb|00| \\
34 & - & \verb|FFFA| & \verb|00| \\
35 & MREQ & \verb|FFF9| & \verb|04| \\
36 & MREQ, WR & \verb|FFF9| & \verb|04| \\
37 & - & \verb|FFF9| & \verb|04| \\
38 & M1, MREQ, RD  & \verb|0038| & \verb|ED|${}^*$ \\
39 & M1, MREQ, RD & \verb|0038| & \verb|ED|${}^*$ \\
40 & MREQ, RFSH & \verb|0005| & \verb|FF| \\
41 & RFSH & \verb|0005| & \verb|FF| \\
42 & M1, MREQ, RD  & \verb|0039| & \verb|4D|${}^*$ \\
43 & M1, MREQ, RD & \verb|0039| & \verb|4D|${}^*$ \\
44 & MREQ, RFSH & \verb|0006| & \verb|FF| \\
45 & RFSH & \verb|0006| & \verb|FF| \\
46 & MREQ, RD  & \verb|FFF9| & \verb|04| \\
47 & MREQ, RD & \verb|FFF9| & \verb|04| \\
48 & - & \verb|FFF9| & \verb|FF| \\
49 & MREQ, RD & \verb|FFFA| & \verb|00| \\
50 & MREQ, RD & \verb|FFFA| & \verb|00| \\
51 & - & \verb|FFFA| & \verb|FF| \\
52 & M1, MREQ, RD & \verb|0004| & \verb|00|${}^*$ \\
53 & M1, MREQ, RD & \verb|0004| & \verb|00|${}^*$ \\
54 & MREQ, RFSH & \verb|0009| & \verb|FF| \\
55 & RFSH & \verb|0009| & \verb|FF| \\
56 & M1, MREQ, RD & \verb|0005| & \verb|00|${}^*$ \\
\hline
\end{tabular}


\subsection{RESTART-Befehl}

\subsubsection{Aufgabe}

Arbeiten Sie einen RST-38H-Befehl ab und halten Sie die Adress- und Datenbussignale fest.

\subsubsection{L"osung}

Der genannte Befehl hat den Opcode \verb|FF|. Zuvor f"uhren wir jedoch noch einen NOP-Befehl aus:

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
1 & M1, MREQ, RD & \verb|0000| & \verb|00|${}^*$ \\
2 & M1, MREQ, RD & \verb|0000| & \verb|00|${}^*$ \\
3 & MREQ, RFSH & \verb|0000| & \verb|FF| \\
4 & RFSH & \verb|0000| & \verb|FF| \\
5 & M1, MREQ, RD & \verb|0001| & \verb|FF|${}^*$ \\
6 & M1, MREQ, RD & \verb|0001| & \verb|FF|${}^*$ \\
7 & MREQ, RFSH & \verb|0001| & \verb|FF| \\
8 & RFSH & \verb|0001| & \verb|FF| \\
9 & - & \verb|0001| & \verb|00| \\
10 & MREQ & \verb|FFFA| & \verb|00| \\
11 & MREQ, WR & \verb|FFFA| & \verb|00| \\
12 & - & \verb|FFFA| & \verb|02| \\
13 & MREQ & \verb|FFF9| & \verb|00| \\
14 & MREQ, WR & \verb|FFF9| & \verb|00| \\
15 & - & \verb|FFF9| & \verb|02| \\
16 & M1, MREQ, RD & \verb|0038| & \verb|00|${}^*$ \\
17 & M1, MREQ, RD & \verb|0038| & \verb|00|${}^*$ \\
18 & MREQ, RFSH & \verb|0002| & \verb|FF| \\
19 & RFSH & \verb|0002| & \verb|FF| \\
20 & M1, MREQ, RD & \verb|0039| & \verb|00|${}^*$ \\
\hline
\end{tabular}
\\

Wie wir sehen: zuerst wird der genannte \verb|NOP|-Befehl ausgef"uhrt. Anschließend f"uhren wir den RST-38H-Befehl aus. Dieser f"uhrt dazu, dass der Inhalt des Program Counters auf dem Stack abgelegt wird und die Ausf"uhrung an der Adresse \verb|0038| fortgesetzt wird. Dort f"uhren wir einmal einen \verb|NOP|-Befehl aus.

\subsection{Registeroperationen}

\subsubsection{Aufgabe}

Führen Sie eine Operation mit den zugänglichen Registern der Z 80 CPU nach eigener Wahl
aus.

\subsubsection{L"osung}

Als ersten Schritt laden wir den Wert \verb|12h| in das Register E. Dazu dient der Befehl \verb|LD E, n| (Opcode \verb|1E| gefolgt vom zu ladenden Wert -- in unserem Fall \verb|12h|):

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
1 & M1, MREQ, RD & \verb|0000| & \verb|1E|${}^*$ \\
2 & M1, MREQ, RD & \verb|0000| & \verb|1E|${}^*$ \\
3 & MREQ, RFSH & \verb|0000| & \verb|FF| \\
4 & RFSH & \verb|0000| & \verb|FF| \\
5 & MREQ, RD & \verb|0001| & \verb|12|${}^*$ \\
6 & MREQ, RD & \verb|0001| & \verb|12|${}^*$ \\
7 & - & \verb|0001| & \verb|FF| \\
\hline
\end{tabular}
\\

Analog laden wir mittels \verb|LD A, n| (\verb|3E| gefolgt vom zu ladenden Wert) den Wert \verb|13h| in das Register A.

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
8 & M1, MREQ, RD & \verb|0002| & \verb|3E|${}^*$ \\
9 & M1, MREQ, RD & \verb|0002| & \verb|3E|${}^*$ \\
10 & MREQ, RFSH & \verb|0001| & \verb|FF| \\
11 & RFSH & \verb|0001| & \verb|FF| \\
12 & MREQ, RD & \verb|0003| & \verb|13|${}^*$ \\
13 & MREQ, RD & \verb|0003| & \verb|13|${}^*$ \\
14 & - & \verb|0003| & \verb|FF| \\
\hline
\end{tabular}
\\

Folgend f"uhren wir den Befehl \verb|add E| (\verb|83|) aus, welcher zum Akkumulator A den Inhalt des Registers E addiert:

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
15 & M1, MREQ, RD & \verb|0004| & \verb|83|${}^*$ \\
16 & M1, MREQ, RD & \verb|0004| & \verb|83|${}^*$ \\
17 & MREQ, RFSH & \verb|0002| & \verb|FF| \\
18 & RFSH & \verb|0002| & \verb|FF| \\
\hline
\end{tabular}
\\

Um an das Ergebnis der Berechnung zu kommen, benutzen wir den Befehl \verb|OUT n| (\verb|D3|), um das Ergebnis auf Port 4 auszugeben und somit bei der Übertragung mitlesen zu k"onnen:

\begin{tabular}[t]{|l|l|l|l|}
\hline
Takt & Kontrollbus & Adressbus & Datenbus \\
\hline
19 & M1, MREQ, RD & \verb|0005| & \verb|D3|${}^*$ \\
20 & M1, MREQ, RD & \verb|0005| & \verb|D3|${}^*$ \\
21 & MREQ, RFSH & \verb|0003| & \verb|FF| \\
22 & RFSH & \verb|0003| & \verb|FF| \\
23 & MREQ, RD & \verb|0006| & \verb|04|${}^*$ \\
24 & MREQ, RD & \verb|0006| & \verb|04|${}^*$ \\
25 & - & \verb|0006| & \verb|FF| \\
26 & - & \verb|2504| & \verb|25| \\
27 & IORQ, WR & \verb|2504| & \verb|25| \\
28 & IORQ, WR & \verb|2504| & \verb|25| \\
29 & - & \verb|2504| & \verb|25| \\
30 & M1, MREQ, RD & \verb|0007| & \verb|00|${}^*$ \\
\hline
\end{tabular}
\\

Wie wir sehen, wird auf Port 4 der Wert 25 ausgegeben.

\bibliography{E10}{}
\bibliographystyle{geralpha}

\end{document}