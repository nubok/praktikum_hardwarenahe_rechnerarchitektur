\documentclass[10pt]{scrartcl}
\usepackage[latin1]{inputenc}
\usepackage[english, ngerman]{babel}
\usepackage[babel]{csquotes}
\usepackage{amsmath} % for eqref
\usepackage{tabularx}
\usepackage{listings} % for listings - of course ;-)
\usepackage{graphicx}
\usepackage[usenames,dvipsnames]{color}
\author{Denis Dietze \and Wolfgang Keller \and Nico Linke \and Thomas Schulte}

\title{Protokoll Versuch IT2}
\subtitle{Microcontroller Z8}
\begin{document}
\maketitle

\lstdefinelanguage{z8asm}
{
morekeywords={ORG,LD,TITLE,CALL,NOP,RET,END,JP},
morecomment=[l]{;}
}

\lstset{
numbers=left,                   % where to put the line-numbers,
commentstyle=\color{OliveGreen},
captionpos=b, % Ist t oder b besser?
showtabs=true,                 % show tabs within strings adding particular underscores
frame=single,	                % adds a frame around the code
tabsize=2	                % sets default tabsize to 2 spaces
}

\section{Port-1-Komplex}

\subsection{Konfiguration von Port 1 zur Speichererweiterung durch 256 Byte externen RAM}
\label{sec:1a}

\subsubsection{Aufgabe}
Konfigurieren Sie Port 1 zur Speichererweiterung durch 256 Byte externen RAM.

\subsubsection{L"osung}

Wir m"ussen in das Register \verb|P01M| den Bin"arwert \verb|XX0100XX| schreiben, wobei X f"ur einen beliebiges Bit steht. Wir haben uns f"ur den Wert \verb|10h| entschieden.

Der Befehl lautet somit: \verb|LD P01M, #%10|.

\subsection{Adressen zum Zugriff auf den externen RAM}
\label{sec:1b}

\subsubsection{Aufgabe}
Über welche Adressen kann auf den externen RAM zugegriffen werden?

\subsubsection{L"osung}
Die ersten 4096 (\verb|1000h|) Adressen sind durch das interne ROM belegt. Alle darüber hinaus gehenden Adressen der mit den 13 Adressbits A0-A12 darstellbaren Adressen (also von \verb|1000h| bis \verb|3000h|) gehören somit \emph{theoretisch} zum externen RAM.

Man kann in der Tat über all diese Adressen auf den externen RAM zugreifen. Jedoch tritt in der Praxis eine Besonderheit auf: wie man in ersten Grafik Anlage 1 der Versuchsbeschreibung sehen kann, sind die Adressbits A8 bis A12 mit Masse verbunden - d. h. im RAM sind nur 256 (\verb|100h|) verschiedene Adressen adressierbar. Die obersten 5 Adressbits (A8-A12) werden ignoriert. Da somit nur 256 Bytes an RAM physikalisch adressierbar sind, wird der Inhalt dieser 256 Bytes in den restlichen mit A0 bis A12 adressierbaren Adressen des externen RAMs zyklisch wiederholt.

\subsection{Befehle zum Zugriff auf den RAM}
\label{sec:1c}

\subsubsection{Aufgabe}

Mit welchen Befehlen kann auf das RAM zugegriffen werden?

\subsubsection{L"osung}

TODO: Nico und Thomas: Inhalt einf"ugen

\subsection{Nutzung eines externen Stacks}
\label{sec:1d}

\subsubsection{Aufgabe}
Programmieren Sie einen externen Stack und legen Sie seine Adresse auf das Ende des unter \ref{sec:1a} konfigurierten externen RAMs. Testen Sie im Schrittbetrieb mittels eines \verb|CALL|-Befehls zur Adresse \verb|500h| und eines \verb|RETURN|-Befehls von dort die korrekte Funktion des Stacks.

Wo liegt exakt die Rücksprungadresse im Stack?

\subsubsection{L"osung}

Gem"a"s den Instruktionen w"ahrend des Praktikums wurde die Aufgabenstellung derart erweitert, dass vor dem \textbf{RETURN}-Befehl ein weiterer Sprung auf die Adresse \verb|600h| mit direkt folgendem Rücksprung erfolgen soll.

\lstinputlisting[caption={Nutzung eines externen Stacks},language=z8asm]{aufgabe31d.asm}

Die R"uckkehradresse liegt dann in der Adresse \verb|0x10FE| auf dem Stack, da der Program Counter 2 Bytes benötigt und entsprechend durch den \verb|CALL|-Befehl wie in Anlage 9 beschrieben der Stack Pointer \verb|SP| um 2 erniedrigt wird und in dieser Adresse der Program Counter \verb|PC| abgespeichert wird.

Wie man in den Zeile 6 und 7 sehen kann, werden SPH bzw. SPL und  (High bzw. Low Byte des Stack Pointers) auf die Adressen \verb|11h| bzw. \verb|00h| gesetzt. Nach den Vorbetrachtungen in Abschnitt \label{sec:1b} stellt dies das Ende des externen unter \label{sec:1a} konfigurierten externen RAMs dar.

Wenn wir uns im Einzelschritt-Betrieb in Zeile 9 befinden, so ist offensichtlich noch kein Wert auf den Stack geschrieben worden. Der Program Counter PC hat den Wert \verb|0015h|.

Wenn wir einen Schritt weitergehen (den \verb|CALL|-Befehl also ausführen), so wird in der Speicheradresse \verb|10FFh| der Wert \verb|00h| und in der Speicheradresse \verb|10FEh| der Wert \verb|18h| abgespeichert. Dies stellt ein Pushen der Adresse des folgenden und Befehls (Zeile 10) in Little-Endian-Darstellung auf den Stack dar. Zudem wurde der Wert des aus SPL und SPH bestehenden Stack Pointers um 2 erniedrigt.

Die Werte sind am Anfang von Zeile 15 also folgendermaßen:
\\

\begin{tabular}{|lr|}
\hline
Register/Speicheradresse & Wert \\
\hline
PC & \verb|500h| \\
SPL & \verb|FE| \\
SPH & \verb|10| \\
\verb|10FEh| & \verb|18h| \\
\verb|10FFh| & \verb|00h| \\
\hline
\end{tabular}
\\

Wenn wir nun einen Schritt weitergehen und Zeile 15 ausführen, so wird der Wert \verb|503h| (der \verb|CALL|-Befehl ist 3 Bytes lang, die zur Adresse \verb|0500h| addiert werden) auf den Stack gepusht und der Program Counter auf den Wert \verb|600h| gesetzt.

Somit sind nach Ausf"uhrung dieser Zeile in den Registern bzw. Speicheradressen folgende Werte abgelegt:
\\

\begin{tabular}{|lr|}
\hline
Register/Speicheradresse & Wert \\
\hline
PC & \verb|600h| \\
SPL & \verb|FC| \\
SPH & \verb|10| \\
\verb|10FCh| & \verb|05h| \\
\verb|10FDh| & \verb|03h| \\
\verb|10FEh| & \verb|18h| \\
\verb|10FFh| & \verb|00h| \\
\hline
\end{tabular}
\\

Wenn nun in Zeile 20 der \verb|RET|-Befehl ausgef"uhrt wird, so wird die Rücksprungadresse vom Stack genommen und im Program Counter abgespeichert. Wir befinden uns also nach Ausf"uhrung von Zeile 20 in Zeile 16.

Die Werte der Register bzw. Speicheradressen enthalten daher folgende Werte:\\

\begin{tabular}{|lr|}
\hline
Register/Speicheradresse & Wert \\
\hline
PC & \verb|503h| \\
SPL & \verb|FE| \\
SPH & \verb|10| \\
\verb|10FEh| & \verb|18h| \\
\verb|10FFh| & \verb|00h| \\
\hline
\end{tabular}
\\

Bei der Ausführung von Zeile 16 wird ein weiteres Mal die R"ucksprungadresse vom Stack genommen, so dass wir als Werte in den Registern nun ablesen k"onnen:\\

\begin{tabular}{|lr|}
\hline
Register/Speicheradresse & Wert \\
\hline
PC & \verb|503h| \\
SPL & \verb|00| \\
SPH & \verb|11| \\
\hline
\end{tabular}

\section{Port-0-/Port-2-Komplex}

\subsection{Zyklische Abfrage und Ausgabe von Schaltern}

\subsubsection{Aufgabe}

Initialisieren Sie Port 0 als Ausgabe- und Port 2 als Eingabe-Port. Entwickeln Sie eine Software, die zyklisch die an Port 2 angeschlossenen Schalter abfragt und die Schaltzust"ande an Port 0 ausgibt.

\subsubsection{L"osung}

\lstinputlisting[caption={Zyklische Abfrage von Ausgabe von Schaltern},language=z8asm]{aufgabe32a.asm}

\subsection{Z"ahlen von Anzahl Schalter"anderungen}

\subsubsection{Aufgabe}

Es ist ein Programm zu entwickeln, welches die Anzahl "Anderungen der Schaltzust"ande an Port 2 z"ahlt und die aktuelle Anzahl "uber Port 0 ausgibt.

Die Abarbeitung soll sowohl im Einzelschrittmodus als auch im normalen Programmablauf erfolgen. Warum ergibt sich ein unterschiedliches Verhalten?

Verbessern Sie das Programm so, dass im normalen Programmablauf das erwartete Verhalten eintritt.

\subsubsection{L"osung}

Eine auf den ersten Blick korrekt erscheinende L"osung sieht folgenderma"sen aus:

\lstinputlisting[caption={Z"ahlen von Anzahl Schalter"anderungen},language=z8asm]{aufgabe32c_ohneschwingung.asm}

In der Tat arbeitet diese im Einzelschrittmodus so, wie man es erwarten w"urde. Wenn man jedoch das Programm normal ablaufen l"asst, stellt man fest, dass beim Umschalten eines Schalters der angezeigte Wert nicht um 1 erh"oht (inkrementiert) wird, sondern um gr"o"sere Werte.

Der Grund liegt darin, dass es sich bei den Schaltern um mechanische Elemente handelt, die beim Umschalten in Schwingung geraten. Daher kommt es kurz nach dem Umschalten zu weiteren kurzzeitigen Umschaltungen, die der Microcontroller registriert und z"ahlt.

Die L"osung ist damit naheliegend: nachdem eine Schalter"anderung detektiert wurde, kurz warten sich sich die Schwingungen beruhigt haben und erst dann mit dem Programmablauf fortfahren. Dies wurde in dem folgenden Programm getan.

\lstinputlisting[caption={Z"ahlen von Anzahl Schalter"anderungen},language=z8asm]{aufgabe32c.asm}

Zur Erkl"arung: prinzipiell k"onnte man ein Abwarten durch \verb|NOP|-Befehle erreichen. Da jedoch recht viele Instruktionsdauern lange gewartet werden muss und die Wartezeit linear in den Anzahl an \verb|NOP|s ist, ist dieser Weg nicht praktikabel.

Stattdessen werden zwei verschachtelte, durch den \verb|DJNZ|-Befehl erzeugte Schleifen verwendet.

in Zeile 29 wird der Registerpointer auf den Wert \verb|10h| gesetzt. Da der \verb|DJNZ| auf Arbeitsregistern operiert (deren absolute Position vom Wert des Registerpointers abh"angt), wird somit garantiert, dass die Nummerierung der aktuellen Arbeitsregister ab Position \verb|10h| (nur die obersten 4 Bits werden ber"ucksichtigt) beginnt.

Normalerweise w"urde man zur Bestimmung der tats"achlich zu wartenden Dauer oszillographische Methoden benutzen, um die Zeitdauer zu bestimmen und anschlie"send die Werte in den Zeilen 32 und 34 an die gemessenen Werte anpassen. Gem"a"s den Anweisungen des Betreuers wurde jedoch hierauf verzichtet.

\section{Timer-1-Komplex}

\subsection{Generierung einer Impulsfolge mit 5 kHz}

\subsubsection{Aufgabe}

Initialisieren Sie Timer 0 (einschlie"slich Prescaler) derart, dass am Portausgang P36 (${T1}_{OUT}$) eine Impulsfolge mit einer Frequenz von 5 kHz geliefert wird (Modulo-N-Mode, OSC=8 MHz, Anlage 5). Porteingang P31 soll hierbei als Toreingang (${T1}_{IN}$) benutzt werden (Aktivierung: High-Pegel über entprellten Schalter S3, Anlage 1).

\subsubsection{L"osung}

TODO: Nico und Thomas: Inhalt einf"ugen

\subsection{Frequenzteiler}

\subsubsection{Aufgabe}

Entwickeln Sie eine Software, die den Timer 1 als Frequenzteiler f"ur eine an P31 (${T1}_{IN}$) anliegende kontinuierliche Frequenzfolge (1 MHz, Generator HM 8035) wirken l"asst. Weisen Sie den maximalen und minimalen Teilerfaktor nach!

\subsubsection{L"osung}

Warnung: diese L"osung ist unvollst"andig. R"ucksprache mit Denis erforderlich!!!

\lstinputlisting[caption={Frequenzteiler},language=z8asm]{aufgabe34b.asm}

\end{document}