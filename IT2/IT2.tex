\documentclass[10pt]{scrartcl}
\usepackage[latin1]{inputenc}
\usepackage[english, ngerman]{babel}
\usepackage[babel]{csquotes}
\usepackage{amsmath} % for eqref
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage[usenames,dvipsnames]{color}
\usepackage{pstricks}
\usepackage{pst-node}
\usepackage{pstricks-add}
\usepackage{listings} % for listings - of course ;-)
\author{Denis Dietze \and Wolfgang Keller \and Nico Linke \and Thomas Schulte}

\title{Protokoll Versuch IT2}
\subtitle{Microcontroller Z8}
\begin{document}
\maketitle

\lstdefinelanguage{z8asm}
{
morekeywords={ORG,CALL,CP,DJNZ,INC,JP,LD,LDE,NOP,RET,RLC,RRC,TITLE,END},
morecomment=[l]{;}
}

\lstset{
numbers=left,                   % where to put the line-numbers,
commentstyle=\color{OliveGreen},
captionpos=b, % Ist t oder b besser?
showtabs=true,                 % show tabs within strings adding particular underscores
frame=single,	                % adds a frame around the code
tabsize=2	                % sets default tabsize to 2 spaces
}

\section{Port-1-Komplex}

\subsection{Konfiguration von Port 1 zur Speichererweiterung durch 256 Byte externen RAM}
\label{sec:1a}

\subsubsection{Aufgabe}
Konfigurieren Sie Port 1 zur Speichererweiterung durch 256 Byte externen RAM.

\subsubsection{L"osung}
\label{sec:1a_lsg}

Wir m"ussen in das Register \verb|P01M| den Bin"arwert \verb|XX0100XX| schreiben, wobei X f"ur ein beliebiges Bit steht. Wir haben uns im Rahmen des Versuchs f"ur den Wert \verb|10h| entschieden.

Der Befehl lautet somit: \verb|LD P01M, #%10|.

\subsection{Adressen zum Zugriff auf den externen RAM}
\label{sec:1b}

\subsubsection{Aufgabe}
Über welche Adressen kann auf den externen RAM zugegriffen werden?

\subsubsection{L"osung}
Die ersten 4096 (\verb|1000h|) Bytes des Speichers sind durch das interne ROM belegt. Alle darüber hinaus gehenden mit den 13 Adressbits A0-A12 darstellbaren Adressen (also von \verb|1000h| bis \verb|3000h|) gehören somit \emph{theoretisch} zum externen RAM.

Man kann in der Tat über all diese Adressen auf den externen RAM zugreifen. Jedoch tritt in der Praxis eine Besonderheit auf: wie man in ersten Grafik Anlage 1 der Versuchsbeschreibung sehen kann, sind die Adressbits A8 bis A12 mit Masse verbunden. Das heißt im RAM sind nur 256 (\verb|100h|) verschiedene Speicherzellen adressierbar. Die obersten 5 Adressbits (A8-A12) werden ignoriert. 

Da somit nur 256 Bytes an RAM physikalisch adressierbar sind, wird der Inhalt dieser 256 Bytes in den restlichen mit A0 bis A12 adressierbaren Adressen des externen RAMs zyklisch wiederholt.

\subsection{Befehle zum Zugriff auf den RAM}
\label{sec:1c}

\subsubsection{Aufgabe}

Mit welchen Befehlen kann auf das RAM zugegriffen werden?

\subsubsection{L"osung}

\begin{table}
\begin{tabular}[t]{|c|l|}
\hline
Register & Bedeutung \\
\hline
R4 & Konstante, welche in den Speicher geschrieben wird \\
R5 & Aus dem Speicher ausgelesener Wert \\
R6 & Speicheradresse \\
\hline
\end{tabular}
\caption{Registerbelegung des Programms zum Zugriff auf den RAM}
\label{table:aufgabe31a}
\end{table}

\begin{figure}
\begin{center}
\begin{pspicture}(5,17)
%\psgrid
\begin{psmatrix}[rowsep=0.4,colsep=0.5]
	\psovalbox{Begin} \\
	~ & [name=Init1] & \makebox[3cm]{} & [name=Init1a]\\
	\psframebox{\parbox{4cm}{10h in P01M schreiben}}  \\
	~ & [name=Init2] \\
	\psframebox{\parbox{4cm}{RP mit 0 initialisieren}} \\
	~ & [name=Init3] \\
	\psframebox{\parbox{4cm}{R6 auf 12h setzen}} \\
	~ & [name=Init4] & \makebox[3cm]{} & [name=Init4a]\\
	\psframebox{\parbox{4cm}{R4 auf 10 setzen}} \\
	\psframebox{\parbox{4cm}{Wert von R4 in die Speicherzelle, deren Adresse in R6 gespeichert ist ablegen}} \\
	\psframebox{\parbox{4cm}{Den Wert der Speicherzelle, deren Adresse in R6 gespeichert ist, in R5 ablegen}} \\
	~ & [name=Check1] \\
	\psframebox{\parbox{4cm}{R4 auf 17 setzen}} \\
	\psframebox{\parbox{4cm}{Wert von R4 in die Speicherzelle, deren Adresse in R6 gespeichert ist ablegen}} \\
	\psframebox{\parbox{4cm}{Den Wert der Speicherzelle, deren Adresse in R6 gespeichert ist, in R5 ablegen}} \\
	~ & [name=Check2] \\
	\psovalbox{End}
\end{psmatrix}
\ncline{->}{1,1}{3,1}
\ncline{->}{3,1}{5,1}
\ncline{->}{5,1}{7,1}
\ncline{->}{7,1}{9,1}
\ncline{->}{9,1}{10,1}
\ncline{->}{10,1}{11,1}
\ncline{->}{11,1}{13,1}
\ncline{->}{13,1}{14,1}
\ncline{->}{14,1}{15,1}
\ncline{->}{15,1}{17,1}
\psbrace[ref=lC](Init2)(Init1){\parbox{3cm}{Konfiguration von Port 1 zur Speichererweiterung durch 256 Byte externen RAM}}
\psbrace[ref=lC](Init3)(Init2){\parbox{3cm}{R6 mit einer zulässigen Adresse initialisieren}}
\psbrace[ref=lC](Init4)(Init3){\parbox{3cm}{Initialisierung des Register Pointers}}
\psbrace[ref=lC](Init4a)(Init1a){\parbox{3cm}{Initialisierung}}
\psbrace[ref=lC](Check1)(Init4){\parbox{6cm}{Erster Test; nach Durchlauf dieses Blocks im Einzelschrittmodus "uberpr"ufen, ob Inhalte von R4 und R5 "ubereinstimmen}}
\psbrace[ref=lC](Check2)(Check1){\parbox{6cm}{Zweiter Test; nach Durchlauf dieses Blocks im Einzelschrittmodus "uberpr"ufen, ob Inhalte von R4 und R5 "ubereinstimmt}}
\end{pspicture}
\vspace{0.5cm}
\end{center}
\caption{Zugriff auf den RAM}
\label{abb:aufgabe31a}
\end{figure}

\begin{figure}
\lstinputlisting[caption={Zugriff auf den RAM},language=z8asm, label=lsg:aufgabe31a]{aufgabe31a.asm}
\end{figure}

Abbildung \ref{abb:aufgabe31a} enthält das Flussdiagramm, auf dem die Assembler-L"osung dieser Aufgabe aus Listing \ref{lsg:aufgabe31a} basiert. Die Tabelle \ref{table:aufgabe31a} beinhaltet die Registerbelegung des Programms.

In Zeile 5 wird der Port wie in Abschnitt \ref{sec:1a_lsg} beschrieben initialisiert. Als nächstes wird in Zeile 6 der Registerpointer (\verb|RP|) initialisiert. Im weiteren Verlauf sind dann alle verwendeten Register als sogenannte Arbeitsregister deklariert. Durch diese Festlegung ist es möglich, bestimmte Operationen effizienter mit weniger Quelltext auszuführen (Register-Pointer-Befehle).

Um zu überprüfen, dass der Speicher richtig initialisiert wurde, werden nun festgelegte Bereiche mit Konstanten beschrieben und wieder ausgelesen.

Register \verb|R6| bekommt einen Wert (eine Speicheradresse) zugewiesen. Dieser muss größer oder gleich \verb|10h| sein (dies hängt damit zusammen, alle Adressen vor diesem Wert vom internen Rom bereits belegt werden). Somit können dort keine Daten gespeichert werden. 

Anschließend wird in Zeile 9 wird eine Konstante (in unserem Fall 10) in das Arbeitsregister \verb|R4| geladen. 

Zeile 10 beschreibt über \verb|@RR6|, dass nun der Speicher an der durch den Wert in \verb|R6| festgelegten Stelle angesprochen und die Konstante aus \verb|R4| dort gespeichert wird.

In der Zeile 12 wird dann der Wert, der an der Adresse von \verb|R6| liegt, ausgelesen und in \verb|R5| geschrieben. Nun vergleicht man im Einzelschrittmodus manuell, ob dieser mit dem in \verb|R4| gespeicherten Wert "ubereinstimmt. Falls dies nicht der Fall sein sollte, so würde liegt ein Fehler im Speicher vorliegen.

Da jedoch auch zuf"alligerweise in der Speicherzelle genau der richtige Wert stehen k"onnte, aber dennoch das Schreiben eventuell nicht funktioniert, muss man den selben Test mit einem anderen Wert (in unserem Fall \verb|17h|) wiederholen.

Erst dann kann man sicher sein, dass das Lesen und Schreiben des Speichers tats"achlich funktioniert.

\subsection{Nutzung eines externen Stacks}
\label{sec:1d}

\subsubsection{Aufgabe}
Programmieren Sie einen externen Stack und legen Sie seine Adresse auf das Ende des unter \ref{sec:1a} konfigurierten externen RAMs. Testen Sie im Schrittbetrieb mittels eines \verb|CALL|-Befehls zur Adresse \verb|500h| und eines \verb|RETURN|-Befehls von dort die korrekte Funktion des Stacks.

Wo liegt exakt die Rücksprungadresse im Stack?

\subsubsection{L"osung}

Der Programmcode, welcher f"ur diese Aufgabe verwendet wurde, befindet sich in Listing \ref{lst:aufgabe31d}.

Gem"a"s den Instruktionen w"ahrend des Praktikums wurde die Aufgabenstellung derart erweitert, dass vor dem \textbf{RETURN}-Befehl ein weiterer Sprung auf die Adresse \verb|600h| mit direkt folgendem Rücksprung erfolgen soll.

\begin{figure}
\lstinputlisting[caption={Nutzung eines externen Stacks},language=z8asm, label=lst:aufgabe31d]{aufgabe31d.asm}
\end{figure}

Die R"uckkehradresse liegt dann in der Adresse \verb|0x10FE| auf dem Stack, da der Program Counter 2 Bytes benötigt und entsprechend durch den \verb|CALL|-Befehl wie in Anlage 9 beschrieben der Stack Pointer \verb|SP| um 2 erniedrigt wird und in dieser Adresse der Program Counter \verb|PC| abgespeichert wird.

Wie man in den Zeile 6 und 7 sehen kann, werden \verb|SPH| bzw. \verb|SPL| und  (High bzw. Low Byte des Stack Pointers) auf die Adressen \verb|11h| bzw. \verb|00h| gesetzt. Nach den Vorbetrachtungen in Abschnitt \ref{sec:1b} stellt dies das Ende des externen unter \ref{sec:1a} konfigurierten externen RAMs dar.

Wenn wir uns im Einzelschritt-Betrieb in Zeile 9 befinden, so ist offensichtlich noch kein Wert auf den Stack geschrieben worden. Der Program Counter \verb|PC| hat den Wert \verb|0015h|.

Wenn wir einen Schritt weitergehen (den \verb|CALL|-Befehl also ausführen), so wird in der Speicheradresse \verb|10FFh| der Wert \verb|00h| und in der Speicheradresse \verb|10FEh| der Wert \verb|18h| abgespeichert. Dies stellt ein Pushen der Adresse des folgenden und Befehls (Zeile 10) in Little-Endian-Darstellung auf den Stack dar. Zudem wurde der Wert des aus \verb|SPL| und \verb|SPH| bestehenden Stack Pointers um 2 erniedrigt.

Die Werte sind am Anfang von Zeile 15 also folgendermaßen:
\\

\begin{tabular}{|c|r|}
\hline
Register/Speicheradresse & Wert \\
\hline
PC & \verb|500h| \\
SPL & \verb|FEh| \\
SPH & \verb|10h| \\
\verb|10FEh| & \verb|18h| \\
\verb|10FFh| & \verb|00h| \\
\hline
\end{tabular}
\\

Wenn wir nun einen Schritt weitergehen und Zeile 15 ausführen, so wird der Wert \verb|503h| (der \verb|CALL|-Befehl ist 3 Bytes lang, die zur Adresse \verb|0500h| addiert werden) auf den Stack gepusht und der Program Counter auf den Wert \verb|600h| gesetzt.

Somit sind nach Ausf"uhrung dieser Zeile in den Registern bzw. Speicheradressen folgende Werte abgelegt:
\\

\begin{tabular}{|c|r|}
\hline
Register/Speicheradresse & Wert \\
\hline
PC & \verb|600h| \\
SPL & \verb|FCh| \\
SPH & \verb|10h| \\
\verb|10FCh| & \verb|05h| \\
\verb|10FDh| & \verb|03h| \\
\verb|10FEh| & \verb|18h| \\
\verb|10FFh| & \verb|00h| \\
\hline
\end{tabular}
\\

Wenn nun in Zeile 20 der \verb|RET|-Befehl ausgef"uhrt wird, so wird die Rücksprungadresse vom Stack genommen und im Program Counter abgespeichert. Wir befinden uns also nach Ausf"uhrung von Zeile 20 in Zeile 16.

Die Werte der Register bzw. Speicheradressen enthalten daher folgende Werte:\\

\begin{tabular}{|c|r|}
\hline
Register/Speicheradresse & Wert \\
\hline
PC & \verb|503h| \\
SPL & \verb|FEh| \\
SPH & \verb|10h| \\
\verb|10FEh| & \verb|18h| \\
\verb|10FFh| & \verb|00h| \\
\hline
\end{tabular}
\\

Bei der Ausführung von Zeile 16 wird ein weiteres Mal die R"ucksprungadresse vom Stack genommen, so dass wir als Werte in den Registern nun ablesen k"onnen:\\

\begin{tabular}{|c|r|}
\hline
Register/Speicheradresse & Wert \\
\hline
PC & \verb|503h| \\
SPL & \verb|00h| \\
SPH & \verb|11h| \\
\hline
\end{tabular}

\section{Port-0-/Port-2-Komplex}

\subsection{Zyklische Abfrage und Ausgabe von Schaltern}

\subsubsection{Aufgabe}

Initialisieren Sie Port 0 als Ausgabe- und Port 2 als Eingabe-Port. Entwickeln Sie eine Software, die zyklisch die an Port 2 angeschlossenen Schalter abfragt und die Schaltzust"ande an Port 0 ausgibt.

\subsubsection{L"osung}

\label{sec:32a_loesung}

\begin{figure}
\begin{center}
\begin{pspicture}(8,7)
%\psgrid
\begin{psmatrix}[rowsep=0.4,colsep=0.5]
	\psovalbox{Begin} \\
	~ & [name=Init1] & \makebox[3cm]{} & [name=Init1a]\\
	\psframebox{\parbox{4cm}{00h in P01M schreiben}}  \\
	~ & [name=Init2] \\
	\psframebox{\parbox{4cm}{FFh in P2M schreiben}}  \\
	~ & [name=Init3] \\
	\psframebox{\parbox{4cm}{01h in P3M schreiben}}  \\
	~ & [name=Init4] & \makebox[3cm]{} & [name=Init4a]\\
	\psframebox{\parbox{4cm}{Lade Wert von Register 2 nach Register 0}}
\end{psmatrix}
\ncline{->}{1,1}{3,1}
\ncline{->}{3,1}{5,1}
\ncline{->}{5,1}{7,1}
\ncline{->}{7,1}{9,1}
\ncangles[angleA=-90, armA=0.5cm, armB=2.5cm]{->}{9,1}{8,1}
\psbrace[ref=lC](Init2)(Init1){\parbox{3cm}{Initialisiere Port 0 f"ur Ausgabe}}
\psbrace[ref=lC](Init3)(Init2){\parbox{3cm}{Definiere alle Bits von Port 2 als Eingabe-Bits}}
\psbrace[ref=lC](Init4)(Init3){\parbox{3cm}{Setze Push-Pull bei Port 2}}
\psbrace[ref=lC](Init4a)(Init1a){\parbox{3cm}{Initialisierung}}
\end{pspicture}
\vspace{0.5cm}
\end{center}
\caption{Zyklische Abfrage und Ausgabe von Schaltern}
\label{abb:aufgabe32a}
\end{figure}

\begin{figure}
\lstinputlisting[caption={Zyklische Abfrage und Ausgabe von Schaltern}, language=z8asm, label=lst:32a]{aufgabe32a.asm}
\end{figure}

Das Flussdiagramm, welches man aus der Programmbesschreibung erhält, befindet sich in Abbildung \ref{abb:aufgabe32a}. Das Assembler-Programm, welches hieraus erzeugt wurde, ist in Listing \ref{lst:32a} zu sehen.

In diesem wird zun"achst der Port 0 als Ausgabe-Port initialisiert. Die Bitbelegung ist dabei \verb|XXX00X00|, wobei X für ein beliebiges Bit steht. Wir haben uns f"ur \verb|0h| entschieden.

Anschließend muss Port 2 als Eingabe-Port initialisiert werden. Hierbei ist Bitbelegung \verb|11111111|, also \verb|FFh|.

Die Initialisierung des Steuerregisters \verb|P3M| mit dem Wert \verb|XXXXXXX1| (in diesem Fall \verb|1h|) scheint dagegen "uberfl"ussig zu sein, da Port 2 nur als \emph{Ausgabe-Port} aktive Pull-Ups ben"otigt. Wir haben es dennoch nicht entfernt, um keine neue Fehlerquelle in der Ausarbeitung einzubauen.

Nach der Initialisierung wird in einer Endlosschleife der Wert von Register 2 (Port-Register von Port 2) nach Register 0 kopiert (Port-Register von Port 0).

\subsection{Zyklische Abfrage und Ausgabe von Schaltern mit Vertauschen von Bitpaaren}

\subsubsection{Aufgabe}

Das Programm ist insoweit zu erweitern, dass zwischen der Ein- und Ausgabe die Bitpaare $D_0-D_7$, $D_1-D_6$, $D_2-D_5$ und $D_3-D_4$ vertauscht werden.

\subsubsection{L"osung}

\begin{figure}
\begin{center}
\begin{pspicture}(8,13)
%\psgrid
\begin{psmatrix}[rowsep=0.4,colsep=0.5]
	\psovalbox{Begin} \\
	~ & [name=Init1] & \makebox[3cm]{} & [name=Init1a]\\
	\psframebox{\parbox{4cm}{00h in P01M schreiben}}  \\
	~ & [name=Init2] \\
	\psframebox{\parbox{4cm}{FFh in P2M schreiben}}  \\
	~ & [name=Init3] \\
	\psframebox{\parbox{4cm}{01h in P3M schreiben}}  \\
	~ & [name=Init4] & \makebox[3cm]{} & [name=Init4a]\\
	\psframebox{\parbox{4cm}{Lade Wert von P2 nach Register 4}} \\
	~ & [name=BeginRep] \\
	\psframebox{\parbox{4cm}{Rotiere Register 4 unter Nutzung des Carry-Flags nach rechts}} \\
	\psframebox{\parbox{4cm}{Rotiere Register 5 unter Nutzung des Carry-Flags nach links}} \\
	~ & [name=EndRep] \\
	\psframebox{\parbox{4cm}{Lade Wert von Register 5 nach P0}}
\end{psmatrix}
\ncline{->}{1,1}{3,1}
\ncline{->}{3,1}{5,1}
\ncline{->}{5,1}{7,1}
\ncline{->}{7,1}{9,1}
\ncline{->}{9,1}{11,1}
\ncline{->}{11,1}{12,1}
\ncline{->}{12,1}{14,1}
\ncangles[angleA=-90, armA=0.5cm, armB=2.5cm]{->}{14,1}{8,1}
\psbrace[ref=lC](Init2)(Init1){\parbox{3cm}{Initialisiere Port 0 f"ur Ausgabe}}
\psbrace[ref=lC](Init3)(Init2){\parbox{3cm}{Definiere alle Bits von Port 2 als Eingabe-Bits}}
\psbrace[ref=lC](Init4)(Init3){\parbox{3cm}{Setze Push-Pull bei Port 2}}
\psbrace[ref=lC](Init4a)(Init1a){\parbox{3cm}{Initialisierung}}
\psbrace[ref=lC](EndRep)(BeginRep){\parbox{3cm}{8 mal nacheinander diesen Block ausf"uhren}}
\end{pspicture}
\vspace{0.5cm}
\end{center}
\caption{Zyklische Abfrage und Ausgabe von Schaltern mit Vertauschen von Bitpaaren}
\label{abb:32a_erweiterung}
\end{figure}

\begin{figure}
\lstinputlisting[caption={Erweiterung der zyklischen Abfrage und Ausgabe von Schaltern um Vertauschung von Bitpaaren}, language=z8asm, label=lst:32a_erweiterung]{aufgabe32a_erweiterung.asm}
\end{figure}

Abbildung \ref{abb:32a_erweiterung} enthält ein Flussdiagramm eines die Aufgabenstellung l"osenden Programms. Listing \ref{lst:32a_erweiterung} ist die komkrete Assembler-L"osung.

Die Initialisierung erfolgt wie in Abschnitt \ref{sec:32a_loesung} beschrieben.

Die Endlosschleife muss gegenüber der vorhergehenden Aufgabe erweitert werden. Zuerst wird der an Port 2 abgefragte Wert der LEDs in das Register 4 geladen. Durch einen Rechts-Rotationsschritt wird das aktuell niedrigste Bit von Register 4 in das Carry-Flag "ubertragen. Anschließend wird dieses durch einen Links-Rotationsschritt als neues h"ochstes Bit nach Register 5 "ubertragen.

Da ein Byte acht Bits enth"alt, muss dies acht mal durchgeführt werden.

Zuletzt wird der Wert von Register 5 nach \verb|P0|, dem Ausgangsport übertragen und zum Anfang der Schleife zur"uckgesprungen.

\subsection{Z"ahlen von Anzahl Schalter"anderungen}
\label{abschn:32c}

\subsubsection{Aufgabe}

Es ist ein Programm zu entwickeln, welches die Anzahl "Anderungen der Schaltzust"ande an Port 2 z"ahlt und die aktuelle Anzahl "uber Port 0 ausgibt.

Die Abarbeitung soll sowohl im Einzelschrittmodus als auch im normalen Programmablauf erfolgen. Warum ergibt sich ein unterschiedliches Verhalten?

Verbessern Sie das Programm so, dass im normalen Programmablauf das erwartete Verhalten eintritt.

\subsubsection{L"osung}

Eine auf den ersten Blick korrekt erscheinende L"osung kann man in Abbildung \ref{abb:aufgabe32c_ohneschwingung} bzw. Listing \ref{lst:aufgabe32c_ohneschwingung} sehen. Die zugeh"orige Registerbelegungstabelle ist Tabelle \ref{table:aufgabe32c_ohneschwingung}.

\begin{table}
\begin{tabular}[t]{|c|l|}
\hline
Register & Bedeutung \\
\hline
4 & Anzahl "Anderungen \\
5 & Alter Wert von Port 2 \\
6 & Neuer Wert von Port 2 \\
\hline
\end{tabular}
\caption{Registerbelegungstabelle f"ur die erste Version (ohne Ber"ucksichtigung von Schwingungen) des Programms zum Z"ahlen der Anzahl von Schalter"anderungen}
\label{table:aufgabe32c_ohneschwingung}
\end{table}

\begin{figure}
\begin{center}
\begin{pspicture}(8,16)
%\psgrid
\begin{psmatrix}[rowsep=0.4,colsep=0.5]
	\psovalbox{Begin} \\
	~ & [name=Init1] \\
	\psframebox{\parbox{4cm}{00h in P01M schreiben}} \\
	\psframebox{\parbox{4cm}{FFh in P2M schreiben}} \\
	\psframebox{\parbox{4cm}{01h in P3M schreiben}} \\
	\psframebox{\parbox{4cm}{Register 4 mit 0 initialisieren}} \\
	\psframebox{\parbox{4cm}{Register 5 mit dem Wert von Port 2 initialisieren}} \\
	\psframebox{\parbox{4cm}{Gib Register 4 nach Port 0 aus}} \\
	~ & [name=Init6] \\
	\psframebox{\parbox{4cm}{Lade Wert von Port 2 nach Register 6}} \\
	\psdiabox{\parbox{2.2cm}{Ist Register 5 = Register 6?}} \\
	\psframebox{\parbox{4cm}{Inkrementiere Register 4}} \\
	\psframebox{\parbox{4cm}{Sende den Wert von Register 4 an Port 0}} \\
	\psframebox{\parbox{4cm}{Speichere den Wert von Register 6 in Register 5}}
	\ncline{->}{1,1}{3,1}
	\ncline{->}{3,1}{4,1}
	\ncline{->}{4,1}{5,1}
	\ncline{->}{5,1}{6,1}
	\ncline{->}{6,1}{7,1}
	\ncline{->}{7,1}{8,1}
	\ncline{->}{8,1}{10,1}
	\ncline{->}{10,1}{11,1}
	\ncline{->}{11,1}{12,1}\nbput{Nein}
	\ncangles[angleA=0, armA=0.5cm, armB=2.5cm]{->}{11,1}{9,1}\nbput{Ja}
	\ncline{->}{12,1}{13,1}
	\ncline{->}{13,1}{14,1}
	\ncangles[angleA=-90, armA=0.5cm, armB=4cm]{->}{14,1}{9,1}
\end{psmatrix}
\psbrace[ref=lC](Init6)(Init1){\parbox{3cm}{Initialisierung}}
\end{pspicture}
\vspace{0.5cm}
\end{center}
\caption{Z"ahlen von Anzahl Schalter"anderungen (ohne Ber"ucksichtigung von Schwingungen)}
\label{abb:aufgabe32c_ohneschwingung}
\end{figure}

\begin{figure}
\lstinputlisting[caption={Z"ahlen von Anzahl Schalter"anderungen (ohne Ber"ucksichtigung von Schwingungen)}, language=z8asm, label=lst:aufgabe32c_ohneschwingung]{aufgabe32c_ohneschwingung.asm}
\end{figure}

In der Tat arbeitet diese im Einzelschrittmodus so, wie man es erwarten w"urde. Wenn man jedoch das Programm normal ablaufen l"asst, stellt man fest, dass beim Umschalten eines Schalters der angezeigte Wert nicht um 1 erh"oht (inkrementiert) wird, sondern um gr"o"sere Werte.

Der Grund liegt darin, dass es sich bei den Schaltern um mechanische Elemente handelt, die beim Umschalten in Schwingung geraten. Daher kommt es kurz nach dem Umschalten zu weiteren kurzzeitigen Umschaltungen, die der Microcontroller registriert und z"ahlt.

Die L"osung ist damit naheliegend: nachdem eine Schalter"anderung detektiert wurde, kurz warten sich sich die Schwingungen beruhigt haben und erst dann mit dem Programmablauf fortfahren. Dies wurde in dem Programm aus Listing \ref{lst:aufgabe32c} getan. Die zugehörige Registerbelegungstabelle ist Tabelle \ref{table:aufgabe32c} und das Flussdiagramm ist Abbildung \ref{abb:aufgabe32c}.

\begin{table}
\begin{tabular}[t]{|c|l|}
\hline
Register & Bedeutung \\
\hline
4 & Anzahl "Anderungen \\
5 & Alter Wert von Port 2 \\
6 & Neuer Wert von Port 2 \\
r0 & Z"ahler "au"sere Schleife \\
r1 & Z"ahler innere Schleife \\
\hline
\end{tabular}
\caption{Registerbelegungstabelle f"ur die zweite Version (unter Ber"ucksichtigung von Schwingungen) des Programms zum Z"ahlen der Anzahl von Schalter"anderungen}
\label{table:aufgabe32c}
\end{table}

\begin{figure}
\begin{center}
\begin{pspicture}(8,17)
%\psgrid
\begin{psmatrix}[rowsep=0.4,colsep=0.5]
	\psovalbox{Begin} \\
	\psframebox{\parbox{4cm}{Initialisierung wie im vorhergehenden Programm}} \\
	[name=Begin] \\
	\psframebox{\parbox{4cm}{Lade Wert von Port 2 nach Register 6}} \\
	\psdiabox{\parbox{2.2cm}{Ist Register 5 = Register 6?}} \\
	\psframebox{\parbox{4cm}{Lade 10h nach RP}} \\
	\psframebox{\parbox{4cm}{Lade FFh nach r0}} \\
	[name=Loop0] \\
	\psframebox{\parbox{4cm}{Lade FFh nach r1}} \\
	[name=Loop1] \\
	\psframebox{\parbox{4cm}{Dekrementiere r1}} \\
	\psdiabox{\parbox{2.2cm}{Ist r1 $\neq$ 0?}} \\
	\psframebox{\parbox{4cm}{Dekrementiere r0}} \\
	\psdiabox{\parbox{2.2cm}{Ist r0 $\neq$ 0?}} \\
	\psframebox{\parbox{4cm}{Inkrementiere Register 4}} \\
	\psframebox{\parbox{4cm}{Sende den Wert von Register 4 Wert an Port 0}} \\
	\psframebox{\parbox{4cm}{Speichere den Wert von Register 6 in Register 5}}
	\ncline{->}{1,1}{2,1}
	\ncline{->}{2,1}{4,1}
	\ncangles[angleA=0, armA=0.5cm, armB=2.5cm]{->}{5,1}{Begin}\nbput{Ja}
	\ncline{->}{4,1}{5,1}
	\ncline{->}{5,1}{6,1}\nbput{Nein}
	\ncline{->}{6,1}{7,1}
	\ncline{->}{7,1}{9,1}
	\ncline{->}{9,1}{11,1}
	\ncline{->}{11,1}{12,1}
	\ncangles[angleA=0, armA=0.5cm, armB=2.5cm]{->}{12,1}{Loop1}\nbput{Ja}
	\ncline{->}{12,1}{13,1}\nbput{Nein}
	\ncline{->}{13,1}{14,1}
	\ncline{->}{14,1}{15,1}\nbput{Nein}
	\ncline{->}{15,1}{16,1}
	\ncline{->}{16,1}{17,1}
	\ncangles[angleA=0, armA=1.5cm, armB=2.5cm]{->}{14,1}{Loop0}\nbput{Ja}
	\ncangles[angleA=-90, armA=0.5cm, armB=5.0cm]{->}{17,1}{Begin}
\end{psmatrix}
\end{pspicture}
\vspace{0.5cm}
\end{center}
\caption{Z"ahlen von Anzahl Schalter"anderungen (unter Ber"ucksichtigung von Schwingungen)}
\label{abb:aufgabe32c}
\end{figure}

\begin{figure}
\lstinputlisting[caption={Z"ahlen von Anzahl Schalter"anderungen (unter Ber"ucksichtigung von Schwingungen)},language=z8asm, label=lst:aufgabe32c]{aufgabe32c.asm}
\end{figure}

Zur Erkl"arung: prinzipiell k"onnte man ein Abwarten durch \verb|NOP|-Befehle erreichen. Da jedoch recht viele Instruktionsdauern lange gewartet werden muss und die Wartezeit linear in den Anzahl an \verb|NOP|s ist, ist dieser Weg nicht praktikabel.

Stattdessen werden zwei verschachtelte, durch den \verb|DJNZ|-Befehl erzeugte Schleifen verwendet.

In Zeile 29 wird der Registerpointer \verb|RP| auf den Wert \verb|10h| gesetzt. Da der \verb|DJNZ| auf Arbeitsregistern operiert (deren absolute Position vom Wert des Registerpointers abh"angt), wird somit garantiert, dass die Nummerierung der aktuellen Arbeitsregister ab Position \verb|10h| (nur die obersten 4 Bits werden ber"ucksichtigt) beginnt.

Normalerweise w"urde man zur Bestimmung der tats"achlich zu wartenden Dauer oszillographische Methoden benutzen, um die Zeitdauer zu bestimmen und anschlie"send die Werte in den Zeilen 32 und 34 an die gemessenen Werte anpassen. Gem"a"s den Anweisungen des Betreuers wurde jedoch hierauf verzichtet.

\section{Timer-1-Komplex}

\subsection{Generierung einer Impulsfolge mit 5 kHz}

\subsubsection{Aufgabe}

Initialisieren Sie Timer 0 (einschlie"slich Prescaler) derart, dass am Portausgang P36 (${T1}_{OUT}$) eine Impulsfolge mit einer Frequenz von 5 kHz geliefert wird (Modulo-N-Mode, OSC=8 MHz, Anlage 5). Porteingang P31 soll hierbei als Toreingang (${T1}_{IN}$) benutzt werden (Aktivierung: High-Pegel über entprellten Schalter S3, Anlage 1).

\subsubsection{L"osung}

\begin{figure}
\lstinputlisting[caption={Generierung einer Impulsfolge mit 5 kHz},language=z8asm,label=lst:34a]{aufgabe34a.asm}
\end{figure}

%Listing \ref{lst:34a} bildet die Assembler-L"osung der Aufgabe.

Als erstes wird das Steuerregister P3M in mit \verb|XX0XXXXX| initialisiert. Das Bit D5 ist dabei zentral, da es P31 auf $T_{in}$ setzt.

Anschließend muss das Timer-Mode-Register mit \verb|10011100| initialisiert werden. Hier erfolgt die richtige Belegung über die Eingangs- und Ausgangssignale (lt. Aufgabenstellung).

Danach werden die Initialwerte des Prescaler 1 und des Timers 1 gesetzt, um dadurch die gewünschte Frequenz von 5 KHz zu bekommen. 

Der Grund, warum sich tats"chlich eine Frequenz von 5~kHz ergibt, l"asst sich aus Abbildung 5 des Aufgabenblattes entnehmen: die am \verb|OSC|-Eingang anliegende Frequenz wird erst einmal durch 2 dividiert. Anschließend wird sie in der Clock Logic nochmals durch  4 dividiert.

Desweiteren wird die Frequenz vor der Ausgabe bei $T_{OUT}$ nochmals durch 2 dividiert.

Wenn somit am Prescaler \verb|PRE1| ein Skalierungsfaktor von 1 und an \verb|T1| ein Skalierungsfaktor von 100 anliegt, so erh"alt man f"ur die an $T_{OUT}$ anliegende Frequenz $f_{T_{OUT}}$:

\begin{eqnarray*}
f_{T_{OUT}} & = & \frac{8~MHz}{2\cdot 4 \cdot 1 \cdot 100 \cdot 2} \\
& = & 5~kHz.
\end{eqnarray*}

Der Prescaler wird außerdem über das Bit D0 in den Modulo N Modus und über D1 in den Input $T_{in}$ Modus gesetzt.

Letztendlich befindet sich im Programm eine Schleife, sodass das Programm nicht unerwünscht terminiert.

\subsection{Frequenzteiler}

\subsubsection{Aufgabe}

Entwickeln Sie eine Software, die den Timer 1 als Frequenzteiler f"ur eine an P31 (${T1}_{IN}$) anliegende kontinuierliche Frequenzfolge (1 MHz, Generator HM 8035) wirken l"asst. Weisen Sie den maximalen und minimalen Teilerfaktor nach!

\subsubsection{L"osung}

\begin{figure}
\lstinputlisting[caption={Frequenzteiler},language=z8asm,label=lst:34b]{aufgabe34b.asm}
\end{figure}

Listing \ref{lst:34a} bildet die Assembler-L"osung der Aufgabe.

Gem"a"s der Abbildung aus Anlage 5 der Aufgabenstellung ist (da der Frequenzgenerator als "`external clock"' an \verb|P31| anliegt und daher nicht als Vorverarbeitungsschritt durch 4 dividiert wird) die an $T_{OUT}$ anliegende Frequenz $f_{T_{OUT}}$ bei Teilerfaktoren von $PRE1_{TF}$ bzw.  $T1_{TF}$ f"ur \verb|PRE1| bzw. \verb|T1|:

\begin{displaymath}
f_{T_{OUT}} = \frac{1~MHz}{2\cdot PRE1_{TF} \cdot T1_{TF}}.
\end{displaymath}

In Tabelle \ref{table:1} sind die Werte der praktischen Messungen, die Werte der Teilerfaktoren $T1_{Init}$ bzw. $PRE1_{Init}$, die zu initialisierenden Werte für die zueg"origen Timerregister \verb|PRE1| bzw. \verb|T1|, die theoretisch zu erwartenden Werte f"ur $f_{T_{OUT}}$, sowie dessen praktische Messwerte abgetragen.

\begin{table}
\begin{minipage}[t]{\textwidth}
\begin{center}
\begin{tabular}{|rr|rr|rr|}
\hline
\multicolumn{2}{|c|}{Teilerfaktor f"ur} &
\multicolumn{2}{c|}{Zu initialisierender Wert f"ur Register} & 
\multicolumn{2}{c|}{$f_{T_{OUT}}$} 
\\
\verb|PRE1| & \verb|T1| & \verb|PRE1| & \verb|T1| & Theorie\footnote{Ergebnisse der Rechnung auf drei Dezimalstellen gerundet} & Messung\\
\hline
1 & 1 & 5 & 1 & 500~kHz & 500,103~kHz\\
64 & 1 & 1 & 1 & 7812,5~Hz & 7814,1~Hz \\
1 & 256 & 5 & 0 & 1953,125~Hz & 1953,52~Hz\\
64 & 256 & 1 & 0 & 30,518~Hz & 30,523~Hz\\
\hline
\end{tabular}
\end{center}
\end{minipage}
\caption{In Aufgabe Frequenzteiler zu bestimmende Werte}
\label{table:1}
\end{table}

\end{document}