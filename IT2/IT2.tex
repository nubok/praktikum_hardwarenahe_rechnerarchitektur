\documentclass[10pt]{scrartcl}
\usepackage[latin1]{inputenc}
\usepackage[english, ngerman]{babel}
\usepackage[babel]{csquotes}
\usepackage{amsmath} % for eqref
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage[usenames,dvipsnames]{color}
\usepackage{pstricks}
\usepackage{pst-node}
\usepackage{pstricks-add}
\usepackage{listings} % for listings - of course ;-)
\author{Denis Dietze \and Wolfgang Keller \and Nico Linke \and Thomas Schulte}

\title{Protokoll Versuch IT2}
\subtitle{Microcontroller Z8}
\begin{document}
\maketitle

\lstdefinelanguage{z8asm}
{
morekeywords={ORG,LD,TITLE,CALL,NOP,RET,END,JP},
morecomment=[l]{;}
}

\lstset{
numbers=left,                   % where to put the line-numbers,
commentstyle=\color{OliveGreen},
captionpos=b, % Ist t oder b besser?
showtabs=true,                 % show tabs within strings adding particular underscores
frame=single,	                % adds a frame around the code
tabsize=2	                % sets default tabsize to 2 spaces
}

\section{Port-1-Komplex}

\subsection{Konfiguration von Port 1 zur Speichererweiterung durch 256 Byte externen RAM}
\label{sec:1a}

\subsubsection{Aufgabe}
Konfigurieren Sie Port 1 zur Speichererweiterung durch 256 Byte externen RAM.

\subsubsection{L"osung}

Wir m"ussen in das Register \verb|P01M| den Bin"arwert \verb|XX0100XX| schreiben, wobei X f"ur einen beliebiges Bit steht. Wir haben uns f"ur den Wert \verb|10h| entschieden.

Der Befehl lautet somit: \verb|LD P01M, #%10|.

\subsection{Adressen zum Zugriff auf den externen RAM}
\label{sec:1b}

\subsubsection{Aufgabe}
Über welche Adressen kann auf den externen RAM zugegriffen werden?

\subsubsection{L"osung}
Die ersten 4096 (\verb|1000h|) Adressen sind durch das interne ROM belegt. Alle darüber hinaus gehenden Adressen der mit den 13 Adressbits A0-A12 darstellbaren Adressen (also von \verb|1000h| bis \verb|3000h|) gehören somit \emph{theoretisch} zum externen RAM.

Man kann in der Tat über all diese Adressen auf den externen RAM zugreifen. Jedoch tritt in der Praxis eine Besonderheit auf: wie man in ersten Grafik Anlage 1 der Versuchsbeschreibung sehen kann, sind die Adressbits A8 bis A12 mit Masse verbunden - d. h. im RAM sind nur 256 (\verb|100h|) verschiedene Adressen adressierbar. Die obersten 5 Adressbits (A8-A12) werden ignoriert. Da somit nur 256 Bytes an RAM physikalisch adressierbar sind, wird der Inhalt dieser 256 Bytes in den restlichen mit A0 bis A12 adressierbaren Adressen des externen RAMs zyklisch wiederholt.

\subsection{Befehle zum Zugriff auf den RAM}
\label{sec:1c}

\subsubsection{Aufgabe}

Mit welchen Befehlen kann auf das RAM zugegriffen werden?

\subsubsection{L"osung}

\begin{figure}
\lstinputlisting[caption={Nutzung eines externen Stacks},language=z8asm, label=aufgabe31a]{aufgabe31a.asm}
\end{figure}

Listing \ref{aufgabe31a} bildet die Assembler-Lösung der Aufgabe.

In Zeile 5 wird der Port wie in Abschnitt \ref{sec:1a} beschrieben initialisiert. Als nächstes wird der Registerpointer (RP) initialisiert. Im weiteren Verlauf sind dann alle verwendeten Register als so genannte Arbeitsregister deklariert. Durch diese Festlegung ist es möglich, bestimmte Operationen effizienter mit weniger Quelltext auszuführen (Register-Pointer-Befehle).

Um zu überprüfen, dass der Speicher richtig initialisiert wurde, werden nun fest gelegte Bereiche mit Konstanten beschrieben und wieder ausgelesen.

In Zeile 8 wird eine Konstante in das Arbeitsregister 4 geladen. Anschließend bekommt das Register 6 ebenfalls einen Wert, dieser muss allerdings größer sein als 10h. Dies hängt damit zusammen, alle Adressen vor diesem Wert vom internen Rom bereits belegt werden. Somit können dort keine Daten gespeichert werden.

Zeile 10 beschreibt über @RR6, dass nun der Speicher an der durch den Wert in R6 festgelegten Stelle angesprochen und die Konstante aus R4 dort gespeichert wird.

Danach bekommt R6 einen anderen Wert, also eine andere Adresse im Speicher. In der Zeile 12 wird dann der Wert, der an der ursprünglichen Adresse von R6 lag ausgelesen und in R5 geschrieben.

Befindet sich dort eine andere Konstante als in R4, trat ein Fehler bei der Initialisierung, bzw. beim Schreiben und Lesen des externen Speichers auf.

Die Zeilen 14-18 zeigen ebenfalls eine nochmalige Kontrolle nach der eben beschriebenen Vorgehensweise. Die Speicheradressen sowie -register sind dabei jedoch anders.

\subsection{Nutzung eines externen Stacks}
\label{sec:1d}

\subsubsection{Aufgabe}
Programmieren Sie einen externen Stack und legen Sie seine Adresse auf das Ende des unter \ref{sec:1a} konfigurierten externen RAMs. Testen Sie im Schrittbetrieb mittels eines \verb|CALL|-Befehls zur Adresse \verb|500h| und eines \verb|RETURN|-Befehls von dort die korrekte Funktion des Stacks.

Wo liegt exakt die Rücksprungadresse im Stack?

\subsubsection{L"osung}

Der Programmcode, welcher f"ur diese Aufgabe verwendet wurde, befindet sich in Listing \ref{lst:aufgabe31d}.

Gem"a"s den Instruktionen w"ahrend des Praktikums wurde die Aufgabenstellung derart erweitert, dass vor dem \textbf{RETURN}-Befehl ein weiterer Sprung auf die Adresse \verb|600h| mit direkt folgendem Rücksprung erfolgen soll.

\begin{figure}
\lstinputlisting[caption={Nutzung eines externen Stacks},language=z8asm, label=lst:aufgabe31d]{aufgabe31d.asm}
\end{figure}

Die R"uckkehradresse liegt dann in der Adresse \verb|0x10FE| auf dem Stack, da der Program Counter 2 Bytes benötigt und entsprechend durch den \verb|CALL|-Befehl wie in Anlage 9 beschrieben der Stack Pointer \verb|SP| um 2 erniedrigt wird und in dieser Adresse der Program Counter \verb|PC| abgespeichert wird.

Wie man in den Zeile 6 und 7 sehen kann, werden SPH bzw. SPL und  (High bzw. Low Byte des Stack Pointers) auf die Adressen \verb|11h| bzw. \verb|00h| gesetzt. Nach den Vorbetrachtungen in Abschnitt \ref{sec:1b} stellt dies das Ende des externen unter \ref{sec:1a} konfigurierten externen RAMs dar.

Wenn wir uns im Einzelschritt-Betrieb in Zeile 9 befinden, so ist offensichtlich noch kein Wert auf den Stack geschrieben worden. Der Program Counter PC hat den Wert \verb|0015h|.

Wenn wir einen Schritt weitergehen (den \verb|CALL|-Befehl also ausführen), so wird in der Speicheradresse \verb|10FFh| der Wert \verb|00h| und in der Speicheradresse \verb|10FEh| der Wert \verb|18h| abgespeichert. Dies stellt ein Pushen der Adresse des folgenden und Befehls (Zeile 10) in Little-Endian-Darstellung auf den Stack dar. Zudem wurde der Wert des aus SPL und SPH bestehenden Stack Pointers um 2 erniedrigt.

Die Werte sind am Anfang von Zeile 15 also folgendermaßen:
\\

\begin{tabular}{|lr|}
\hline
Register/Speicheradresse & Wert \\
\hline
PC & \verb|500h| \\
SPL & \verb|FE| \\
SPH & \verb|10| \\
\verb|10FEh| & \verb|18h| \\
\verb|10FFh| & \verb|00h| \\
\hline
\end{tabular}
\\

Wenn wir nun einen Schritt weitergehen und Zeile 15 ausführen, so wird der Wert \verb|503h| (der \verb|CALL|-Befehl ist 3 Bytes lang, die zur Adresse \verb|0500h| addiert werden) auf den Stack gepusht und der Program Counter auf den Wert \verb|600h| gesetzt.

Somit sind nach Ausf"uhrung dieser Zeile in den Registern bzw. Speicheradressen folgende Werte abgelegt:
\\

\begin{tabular}{|lr|}
\hline
Register/Speicheradresse & Wert \\
\hline
PC & \verb|600h| \\
SPL & \verb|FC| \\
SPH & \verb|10| \\
\verb|10FCh| & \verb|05h| \\
\verb|10FDh| & \verb|03h| \\
\verb|10FEh| & \verb|18h| \\
\verb|10FFh| & \verb|00h| \\
\hline
\end{tabular}
\\

Wenn nun in Zeile 20 der \verb|RET|-Befehl ausgef"uhrt wird, so wird die Rücksprungadresse vom Stack genommen und im Program Counter abgespeichert. Wir befinden uns also nach Ausf"uhrung von Zeile 20 in Zeile 16.

Die Werte der Register bzw. Speicheradressen enthalten daher folgende Werte:\\

\begin{tabular}{|lr|}
\hline
Register/Speicheradresse & Wert \\
\hline
PC & \verb|503h| \\
SPL & \verb|FE| \\
SPH & \verb|10| \\
\verb|10FEh| & \verb|18h| \\
\verb|10FFh| & \verb|00h| \\
\hline
\end{tabular}
\\

Bei der Ausführung von Zeile 16 wird ein weiteres Mal die R"ucksprungadresse vom Stack genommen, so dass wir als Werte in den Registern nun ablesen k"onnen:\\

\begin{tabular}{|lr|}
\hline
Register/Speicheradresse & Wert \\
\hline
PC & \verb|503h| \\
SPL & \verb|00| \\
SPH & \verb|11| \\
\hline
\end{tabular}

\section{Port-0-/Port-2-Komplex}

\subsection{Zyklische Abfrage und Ausgabe von Schaltern}

\subsubsection{Aufgabe}

Initialisieren Sie Port 0 als Ausgabe- und Port 2 als Eingabe-Port. Entwickeln Sie eine Software, die zyklisch die an Port 2 angeschlossenen Schalter abfragt und die Schaltzust"ande an Port 0 ausgibt.

\subsubsection{L"osung}

Das Flussdiagramm, welches man aus der Programmbesschreibung erhält, befindet sich in Abbildung \ref{abb:1}. Das Assembler-Programm, welches hieraus erzeugt wurde, ist in Listing \ref{lst:32a} zu sehen.

\begin{figure}
\begin{center}
\begin{pspicture}(8,8)
%\psgrid
\begin{psmatrix}[rowsep=0.4,colsep=0.5]
	\psovalbox{Begin} \\
	~ & [name=Init1] & \makebox[3cm]{} & [name=Init1a]\\
	\psframebox{00h in P01M schreiben}  \\
	~ & [name=Init2] \\
	\psframebox{FFh in P2M schreiben}  \\
	~ & [name=Init3] \\
	\psframebox{01h in P3M schreiben}  \\
	~ & [name=Init4] & \makebox[3cm]{} & [name=Init4a]\\
	\psframebox{\parbox{4cm}{Lade Wert von Register 2 nach Register 0}}
\end{psmatrix}
\ncline{->}{1,1}{3,1}
\ncline{->}{3,1}{5,1}
\ncline{->}{5,1}{7,1}
\ncline{->}{7,1}{9,1}
\ncangles[angleA=-90, armA=0.5cm, armB=2.5cm]{->}{9,1}{8,1}
\psbrace[ref=lC](Init2)(Init1){\parbox{3cm}{Initialisiere Port 0 f"ur Ausgabe}}
\psbrace[ref=lC](Init3)(Init2){\parbox{3cm}{Definiere alle Bits von Port 2 als Eingabe-Bits}}
\psbrace[ref=lC](Init4)(Init3){\parbox{3cm}{Setze Push-Pull bei Port 2}}
\psbrace[ref=lC](Init4a)(Init1a){\parbox{3cm}{Initialisierung}}
\end{pspicture}
\vspace{0.5cm}
\end{center}
\caption{Zyklische Abfrage und Ausgabe von Schaltern}
\label{abb:1}
\end{figure}

\begin{figure}
\lstinputlisting[caption={Zyklische Abfrage und Ausgabe von Schaltern}, language=z8asm, label=lst:32a]{aufgabe32a.asm}
\end{figure}

\subsubsection{Aufgabe}

Das Programm ist insoweit zu erweitern, dass zwischen der Ein- und Ausgabe die Bitpaare $D_0-D_7$, $D_1-D_6$, $D_2-D_5$ und $D_3-D_4$ vertauscht werden.

\subsubsection{L"osung}

\begin{figure}
\lstinputlisting[caption={Erweiterung des zyklischen Abfrage und Ausgabe von Schaltern um Vertauschung von Bitpaaren}, language=z8asm, label=lst:32a_erweiterung]{aufgabe32a_erweiterung.asm}
\end{figure}

Listing \ref{lst:32a_erweiterung} bildet die Assembler-L"osung der Aufgabe.

Zunächst wird der Port 0 als Ausgabe-Port initialisiert. Die Bitbelegung ist dabei XXX00X00, wobei X für ein beliebiges Bit steht.

Anschließend muss Port 2 als Eingabe-Port initialisiert werden. Hierbei ist Bitbelegung 11111111, demzufolge in Hex FF.
In Zeile 7 wird dann das Steuerregister P3M initialisiert. Dies ist wichtig, da der Port 2 als Ausgabe-Port aktive Pull-Ups benötigt.

Die Bitbelegung ist dort also XXXXXXX1 -- f"ur die L"osung wurde sich f"ur \verb|1h| entschieden.

Nach der Initialisierung der benötigten Ports folgt nun eine Schleife, da lt. Aufgabenstellung die Schalter zyklisch abgefragt werden sollen.
Dort wird der abgefragte Wert der LED's aus Port 2 in das Register 4 geladen. Danach wird dieser Wert in P0, dem Ausgangsport geladen.
Somit leuchten dort die jeweiligen LED's auf. Zum Schluss erfolgt ein Sprung zurück zum Anfang der Schleife, damit eine neue Anfrage gestartet wird.

\subsection{Z"ahlen von Anzahl Schalter"anderungen}
\label{abschn:32c}



\subsubsection{Aufgabe}

Es ist ein Programm zu entwickeln, welches die Anzahl "Anderungen der Schaltzust"ande an Port 2 z"ahlt und die aktuelle Anzahl "uber Port 0 ausgibt.

Die Abarbeitung soll sowohl im Einzelschrittmodus als auch im normalen Programmablauf erfolgen. Warum ergibt sich ein unterschiedliches Verhalten?

Verbessern Sie das Programm so, dass im normalen Programmablauf das erwartete Verhalten eintritt.

\subsubsection{L"osung}

Eine auf den ersten Blick korrekt erscheinende L"osung kann man in Abbildung \ref{abb:aufgabe32c_ohneschwingung} bzw. Listing \ref{lst:aufgabe32c_ohneschwingung} sehen. Die zugeh"orige Registerbelegungstabelle ist Tabelle \ref{table:aufgabe32c_ohneschwingung}.

\begin{table}
\begin{tabular}[t]{|c|l|}
\hline
Register & Bedeutung \\
\hline
4 & Anzahl "Anderungen \\
5 & Alter Wert von Port 2 \\
6 & Neuer Wert von Port 2 \\
\hline
\end{tabular}
\caption{Registerbelegungstabelle f"ur die erste Version (ohne Ber"ucksichtigung von Schwingungen) des in Abschnitt \ref{abschn:32c} zu erstellende Programms}
\label{table:aufgabe32c_ohneschwingung}
\end{table}

\begin{figure}
\begin{center}
\begin{pspicture}(8,16)
%\psgrid
\begin{psmatrix}[rowsep=0.4,colsep=0.5]
	\psovalbox{Begin} \\
	~ & [name=Init1] \\
	\psframebox{\parbox{4cm}{00h in P01M schreiben}} \\
	\psframebox{\parbox{4cm}{FFh in P2M schreiben}} \\
	\psframebox{\parbox{4cm}{01h in P3M schreiben}} \\
	\psframebox{\parbox{4cm}{Register 4 mit 0 initialisieren}} \\
	\psframebox{\parbox{4cm}{Register 5 mit dem Wert von Port 2 initialisieren}} \\
	\psframebox{\parbox{4cm}{Gib Register 4 nach Port 0 aus}} \\
	~ & [name=Init6] \\
	\psframebox{\parbox{4cm}{Lade Wert von Port 2 nach Register 6}} \\
	\psdiabox{\parbox{2.2cm}{Ist Register 5 = Register 6?}} \\
	\psframebox{\parbox{4cm}{Inkrementiere Register 4}} \\
	\psframebox{\parbox{4cm}{Sende Wert von Register 4 an Port 0}} \\
	\psframebox{\parbox{4cm}{Speichere Wert von Register 6 in Register 5}}
	\ncline{->}{1,1}{3,1}
	\ncline{->}{3,1}{4,1}
	\ncline{->}{4,1}{5,1}
	\ncline{->}{5,1}{6,1}
	\ncline{->}{6,1}{7,1}
	\ncline{->}{7,1}{8,1}
	\ncline{->}{8,1}{10,1}
	\ncline{->}{10,1}{11,1}
	\ncline{->}{11,1}{12,1}\nbput{Nein}
	\ncangles[angleA=0, armA=0.5cm, armB=2.5cm]{->}{11,1}{9,1}\nbput{Ja}
	\ncline{->}{12,1}{13,1}
	\ncline{->}{13,1}{14,1}
	\ncangles[angleA=-90, armA=0.5cm, armB=4cm]{->}{14,1}{9,1}
\end{psmatrix}
\psbrace[ref=lC](Init6)(Init1){\parbox{3cm}{Initialisierung}}
\end{pspicture}
\vspace{0.5cm}
\end{center}
\caption{Z"ahlen von Anzahl Schalter"anderungen (ohne Ber"ucksichtigung von Schwingungen)}
\label{abb:aufgabe32c_ohneschwingung}
\end{figure}

\begin{figure}
\lstinputlisting[caption={Z"ahlen von Anzahl Schalter"anderungen (ohne Ber"ucksichtigung von Schwingungen)}, language=z8asm, label=lst:aufgabe32c_ohneschwingung]{aufgabe32c_ohneschwingung.asm}
\end{figure}

In der Tat arbeitet diese im Einzelschrittmodus so, wie man es erwarten w"urde. Wenn man jedoch das Programm normal ablaufen l"asst, stellt man fest, dass beim Umschalten eines Schalters der angezeigte Wert nicht um 1 erh"oht (inkrementiert) wird, sondern um gr"o"sere Werte.

Der Grund liegt darin, dass es sich bei den Schaltern um mechanische Elemente handelt, die beim Umschalten in Schwingung geraten. Daher kommt es kurz nach dem Umschalten zu weiteren kurzzeitigen Umschaltungen, die der Microcontroller registriert und z"ahlt.

Die L"osung ist damit naheliegend: nachdem eine Schalter"anderung detektiert wurde, kurz warten sich sich die Schwingungen beruhigt haben und erst dann mit dem Programmablauf fortfahren. Dies wurde in dem Programm aus Listing \ref{lst:aufgabe32c} getan. Die zugehörige Registerbelegungstabelle ist Tabelle \ref{table:aufgabe32c} und das Flussdiagramm ist Abbildung \ref{abb:aufgabe32c}.

\begin{table}
\begin{tabular}[t]{|c|l|}
\hline
Register & Bedeutung \\
\hline
4 & Anzahl "Anderungen \\
5 & Alter Wert von Port 2 \\
6 & Neuer Wert von Port 2 \\
r0 & Z"ahler "au"sere Schleife \\
r1 & Z"ahler innere Schleife \\
\hline
\end{tabular}
\caption{Registerbelegungstabelle f"ur die zweite Version (unter Ber"ucksichtigung von Schwingungen) des in Abschnitt \ref{abschn:32c} zu erstellende Programms}
\label{table:aufgabe32c}
\end{table}

\begin{figure}
\begin{center}
\begin{pspicture}(8,20)
%\psgrid
\begin{psmatrix}[rowsep=0.4,colsep=0.5]
	\psovalbox{Begin} \\
	~ & [name=Init1] \\
	\psframebox{\parbox{4cm}{00h in P01M, FFh in P2M, 01h in P3M schreiben}} \\
	\psframebox{\parbox{4cm}{Register 4 mit 0 initialisieren, Register 5 mit dem Wert von Port 2 initialisieren, gib Register 4 nach Port 0 aus}} \\
	~ & [name=Init6] \\
	\psframebox{\parbox{4cm}{Lade Wert von Port 2 nach Register 6}} \\
	\psdiabox{\parbox{2.2cm}{Ist Register 5 = Register 6?}} \\
	\psframebox{\parbox{4cm}{Lade 10h nach RP, FFh nach r0}} \\
	[name=Loop0] \\
	\psframebox{\parbox{4cm}{Lade FFh nach r1}} \\
	[name=Loop1] \\
	\psframebox{\parbox{4cm}{Dekrementiere r1}} \\
	\psdiabox{\parbox{2.2cm}{Ist r1 $\neq$ 0?}} \\
	\psframebox{\parbox{4cm}{Dekrementiere r0}} \\
	\psdiabox{\parbox{2.2cm}{Ist r0 $\neq$ 0?}} \\
	\psframebox{\parbox{4cm}{Inkrementiere Register 4, sende den neuen Wert an Port 0, speichere Wert von Register 6 in Register 5}}
	\ncline{->}{1,1}{3,1}
	\ncline{->}{3,1}{4,1}
	\ncline{->}{4,1}{6,1}
	\ncline{->}{6,1}{7,1}
	\ncangles[angleA=0, armA=0.5cm, armB=2.5cm]{->}{7,1}{5,1}\nbput{Ja}
	\ncline{->}{7,1}{8,1}\nbput{Nein}
	\ncline{->}{8,1}{9,1}
	\ncline{->}{9,1}{10,1}
	\ncline{->}{10,1}{12,1}
	\ncline{->}{12,1}{13,1}
	\ncangles[angleA=0, armA=0.5cm, armB=2.5cm]{->}{13,1}{Loop1}\nbput{Ja}
	\ncline{->}{13,1}{14,1}\nbput{Nein}
	\ncline{->}{14,1}{15,1}
	\ncline{->}{15,1}{16,1}\nbput{Nein}
	\ncangles[angleA=0, armA=1.5cm, armB=2.5cm]{->}{15,1}{Loop0}\nbput{Ja}
	\ncangles[angleA=-90, armA=0.5cm, armB=5.0cm]{->}{16,1}{5,1}
\end{psmatrix}
\psbrace[ref=lC](Init6)(Init1){\parbox{3cm}{Initialisierung}}
\end{pspicture}
\vspace{0.5cm}
\end{center}
\caption{Z"ahlen von Anzahl Schalter"anderungen (unter Ber"ucksichtigung von Schwingungen)}
\label{abb:aufgabe32c}
\end{figure}

\begin{figure}
\lstinputlisting[caption={Z"ahlen von Anzahl Schalter"anderungen (unter Ber"ucksichtigung von Schwingungen)},language=z8asm, label=lst:aufgabe32c]{aufgabe32c.asm}
\end{figure}

Zur Erkl"arung: prinzipiell k"onnte man ein Abwarten durch \verb|NOP|-Befehle erreichen. Da jedoch recht viele Instruktionsdauern lange gewartet werden muss und die Wartezeit linear in den Anzahl an \verb|NOP|s ist, ist dieser Weg nicht praktikabel.

Stattdessen werden zwei verschachtelte, durch den \verb|DJNZ|-Befehl erzeugte Schleifen verwendet.

In Zeile 29 wird der Registerpointer auf den Wert \verb|10h| gesetzt. Da der \verb|DJNZ| auf Arbeitsregistern operiert (deren absolute Position vom Wert des Registerpointers abh"angt), wird somit garantiert, dass die Nummerierung der aktuellen Arbeitsregister ab Position \verb|10h| (nur die obersten 4 Bits werden ber"ucksichtigt) beginnt.

Normalerweise w"urde man zur Bestimmung der tats"achlich zu wartenden Dauer oszillographische Methoden benutzen, um die Zeitdauer zu bestimmen und anschlie"send die Werte in den Zeilen 32 und 34 an die gemessenen Werte anpassen. Gem"a"s den Anweisungen des Betreuers wurde jedoch hierauf verzichtet.

\section{Timer-1-Komplex}

\subsection{Generierung einer Impulsfolge mit 5 kHz}

\subsubsection{Aufgabe}

Initialisieren Sie Timer 0 (einschlie"slich Prescaler) derart, dass am Portausgang P36 (${T1}_{OUT}$) eine Impulsfolge mit einer Frequenz von 5 kHz geliefert wird (Modulo-N-Mode, OSC=8 MHz, Anlage 5). Porteingang P31 soll hierbei als Toreingang (${T1}_{IN}$) benutzt werden (Aktivierung: High-Pegel über entprellten Schalter S3, Anlage 1).

\subsubsection{L"osung}

\begin{figure}
\lstinputlisting[caption={Generierung einer Impulsfolge mit 5 kHz},language=z8asm,label=lst:34a]{aufgabe34a.asm}
\end{figure}

Listing \ref{lst:34a} bildet die Assembler-L"osung der Aufgabe.

ALs erstes wird das Steuerregister P3M in folgender Belegung initialisiert: XX0XXXXX. D5 ist dabei sehr wichtig, da es P31 auf $T_{in}$ setzt.

Anschließend muss das Timer-Mode-Register wie folgt initialisiert werden: 10011100 Hier erfolgt die richtige Belegung über die Eingangs- und Ausgangssignale (lt. Aufgabenstellung).

Danach werden die Initialwerte des Prescaler 1 und des Timers 1 gesetzt, um dadurch die gewünschte Frequenz von 5 KHz zu bekommen. Der Prescaler wird außerdem über das Bit D0 in den Modulo N Modus und über D1 in den Input $T_{in}$ Modus gesetzt.

Letztendlich befindet sich im Programm eine Schleife, sodass das Programm nicht unerwünscht terminiert.

\subsection{Frequenzteiler}

\subsubsection{Aufgabe}

Entwickeln Sie eine Software, die den Timer 1 als Frequenzteiler f"ur eine an P31 (${T1}_{IN}$) anliegende kontinuierliche Frequenzfolge (1 MHz, Generator HM 8035) wirken l"asst. Weisen Sie den maximalen und minimalen Teilerfaktor nach!

\subsubsection{L"osung}

Warnung: diese L"osung ist unvollst"andig. R"ucksprache mit Denis erforderlich!!!

\begin{figure}
\lstinputlisting[caption={Frequenzteiler},language=z8asm,label=lst:34b]{aufgabe34b.asm}
\end{figure}

Listing \ref{lst:34a} bildet die Assembler-L"osung der Aufgabe.

Gem"a"s der Abbildung aus Anlage 5 der Aufgabenstellung ist die an $T_{OUT}$ anliegende Frequenz $f_{T_{OUT}}$ bei Teilerfaktoren von $PRE1_{TF}$ bzw.  $T1_{TF}$ f"ur \verb|PRE1| bzw. \verb|T1|:

\begin{displaymath}
f_{T_{OUT}} = \frac{1~MHz}{2\cdot PRE1_{TF} \cdot T1_{TF}}.
\end{displaymath}

In Tabelle \ref{table:1} sind die Werte der praktischen Messungen, die Werte der Teilerfaktoren $T1_{Init}$ bzw. $PRE1_{Init}$, die zu initialisierenden Werte für die zueg"origen Timerregister \verb|PRE1| bzw. \verb|T1|, die theoretisch zu erwartenden Werte f"ur $f_{T_{OUT}}$, sowie dessen praktische Messwerte abgetragen.

\begin{table}
\begin{minipage}[t]{\textwidth}
\begin{center}
\begin{tabular}{|rr|rr|rr|}
\hline
\multicolumn{2}{|c|}{Teilerfaktor f"ur} &
\multicolumn{2}{c|}{Zu initialisierender Wert f"ur Register} & 
\multicolumn{2}{c|}{$f_{T_{OUT}}$} 
\\
\verb|PRE1| & \verb|T1| & \verb|PRE1| & \verb|T1| & Theorie\footnote{Ergebnisse der Rechnung auf drei Dezimalstellen gerundet} & Messung\\
\hline
1 & 1 & 5 & 1 & 500~kHz & 500,103~kHz\\
64 & 1 & 1 & 1 & 7812,5~Hz & 7814,1~Hz \\
1 & 256 & 5 & 0 & 1953,125~Hz & 1953,52~Hz\\
64 & 256 & 1 & 0 & 30,518~Hz & 30,523~Hz\\
\hline
\end{tabular}
\end{center}
\end{minipage}
\caption{In Aufgabe Frequenzteiler zu bestimmende Werte}
\label{table:1}
\end{table}

\end{document}