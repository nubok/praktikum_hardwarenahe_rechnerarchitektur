Quelltexte und Beschreibungen:

(3.1a)

	TITLE "Aufgabe 3.1a"

	ORG %C

	LD P01M, #%10
	LD RP, 	#0

	LD R4, #10	; (Kostante)
	LD R6, #%12
	LDE @RR6, R4
	LD R6, #%17
	LDE R5, @RR6

	LD R8, #18	; (weitere Konstante)
	LD R6, #%14
	LDE @RR6, R8
	LD R6, #%20
	LDE R9, @RR6

	NOP

	END

Zunächst einmal wird mit Zeile 5 der Port 1 initialisiert.
<< Erklärung von Wolfgang zur Initialisierung hier hin. >>
Als nächstes wird der Registerpointer (RP) initialisiert. Im weiteren Verlauf sind dann alle verwendeten Register als so genannte Arbeitsregister deklariert.
Durch diese Festlegung ist es möglich, bestimmte Operationen effizienter mit weniger Quelltext auszuführen. (Register-Pointer-Befehle)
Um zu überprüfen, dass der Speicher richtig initialisiert wurde, werden nun fest gelegte Bereiche mit Konstanten beschrieben und wieder ausgelesen.
In Zeile 8 wird eine Konstante in das Arbeitsregister 4 geladen. Anschließend bekommt das Register 6 ebenfalls einen Wert, dieser muss allerdings größer sein als Hexa-10.
Dies hängt damit zusammen, alle Adressen vor diesem Wert vom internen Rom bereits belegt werden. Somit können dort keine Daten gespeichert werden.
Zeile 10 beschreibt über @RR6, dass nun der Speicher an der durch den Wert in R6 festgelegten Stelle angesprochen und die Konstante aus R4 dort gespeichert wird.
Danach bekommt R6 einen anderen Wert, also eine andere Adresse im Speicher. In der Zeile 12 wird dann der Wert, der an der ursprünglichen Adresse von R6 lag ausgelesen und in R5 geschrieben.
Befindet sich dort eine andere Konstante als in R4, trat ein Fehler bei der Initialisierung, bzw. beim Schreiben und Lesen des externen Speichers auf.
Die Zeilen 14-18 zeigen ebenfalls eine nochmalige Kontrolle nach der eben beschriebenen Vorgehensweise. Die Speicheradressen sowie -register sind dabei jedoch anders.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

(3.2a)

	TITLE "Aufgabe 3.2a"

	ORG %C
	
	LD P01M, #%0
	LD P2M, #%FF
	LD P3M, #%01

START	LD 4,P2
	LD P0,4
	JP START
	END

Zunächst wird der Port 0 als Ausgabe-Port initialisiert. Die Bitbelegung ist dabei XXX00X00, wobei X für ein beliebiges Bit steht.
Anschließend muss Port 2 als Eingabe-Port initialisiert werden. Hierbei ist Bitbelegung 11111111, demzufolge in Hex FF.
In Zeile 7 wird dann das Steuerregister P3M initialisiert. Dies ist wichtig, da der Port 2 als Ausgabe-Port aktive Pull-Ups benötigt.
Die Bitbelegung ist dort also XXXXXXX1.
Nach der Initialisierung der benötigten Ports folgt nun eine Schleife, da lt. Aufgabenstellung die Schalter zyklisch abgefragt werden sollen.
Dort wird der abgefragte Wert der LED's aus Port 2 in das Register 4 geladen. Danach wird dieser Wert in P0, dem Ausgangsport geladen.
Somit leuchten dort die jeweiligen LED's auf. Zum Schluss erfolgt ein Sprung zurück zum Anfang der Schleife, damit eine neue Anfrage gestartet wird.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

(3.2a - Erweiterung (Vertauschung der LED's, Do-D7, D1-D6, D2-D5, D3-D4))
01	TITLE "Aufgabe 3.2a - Erweiterung"
02 
03	ORG %C
04	
05	LD P01M, #%0
06	LD P2M, #%FF
07	LD P3M, #%01
08
09	START	LD 4,P2
10	
11		RRC 4
12		RLC 5
13		RRC 4
14		RLC 5
15		RRC 4
16		RLC 5
17		RRC 4
18		RLC 5
19		RRC 4
20		RLC 5
21		RRC 4
22		RLC 5
23		RRC 4
24		RLC 5
25		RRC 4
26		RLC 5
27
28		LD P0,5
29		JP START
30	END

Durch diese Erweiterung werden lediglich die LED's vertauscht. Dafür muss für jede LED (jedes Bit) sowohl nach rechts, als auch nach links rotiert werden.
Da es sich in unserem Fall um 8 LED's handelt, 8-mal nach rechts und links rotiert werden.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

(3.4a)

01	TITLE "Aufgabe 3.4a"
02
03	ORG %C
04
05	LD P3M, #%0
06	LD TMR, #%9C
07	LD PRE1, #%05
08	LD T1, #100
09
10	START	JP START
11
12	END

ALs erstes wird das Steuerregister P3M in folgender Belegung initialisiert: XX0XXXXX. D5 ist dabei sehr wichtig, da es P31 auf T_in setzt.
Anschließend muss das Timer-Mode-Register wie folgt initialisiert werden: 10011100 Hier erfolgt die richtige Belegung über die Eingangs- und Ausgangssignale. (lt. Aufgabenstellung)
Danach werden die Initialwerte des Prescaler 1 und des Timers 1 gesetzt, um dadurch die gewünschte Frequenz von 5 KHz zu bekommen. Der Prescaler wird außerdem über das Bit D0 in den Modulo N Modus und über D1 in den Input T_in Modus gesetzt.
Letztendlich befindet sich im Programm eine Schleife, sodass das Programm nicht unerwünscht terminiert.
